import numpy as np

def HDBSCAN(X, MIN_SAMPLES=5):

    def __COMPUTE_CORE_DISTANCES__(X):
        DISTANCES = PAIRWISE_DISTANCES(X)
        SORTED_DISTANCES = np.sort(DISTANCES, axis=0)
        CORE_DISTANCES = SORTED_DISTANCES[MIN_SAMPLES - 1]
        return CORE_DISTANCES

    def __COMPUTE_NEIGHBOURS__(X, CORE_DISTANCES):
        NEIGHBOURS = np.argwhere(PAIRWISE_DISTANCES(X) <= CORE_DISTANCES)[:, 1]
        return NEIGHBOURS

    def __CONDENSE_TREE__(X, NEIGHBOURS, CORE_DISTANCES):
        CONDENSED_TREE = {}
        for IDX, _ in enumerate(X):
            NEIGHBOURS = NEIGHBOURS[NEIGHBOURS == IDX]
            if len(NEIGHBOURS) > 0:
                MIN_DISTANCE_IDX = np.argmin(CORE_DISTANCES[NEIGHBOURS])
                NEAREST_NEIGHBOUR = NEIGHBOURS[MIN_DISTANCE_IDX]
                EDGE_LENGTH = CORE_DISTANCES[NEAREST_NEIGHBOUR]
                CONDENSED_TREE[(IDX, NEAREST_NEIGHBOUR)] = EDGE_LENGTH
        return CONDENSED_TREE

    def __EXTRACT_CLUSTERS__(CONDENSED_TREE, N_SAMPLES):
        LABELS = np.full(N_SAMPLES, -1)
        CLUSTER_ID = 0
        for EDGE, _ in sorted(CONDENSED_TREE.items(), key=lambda x: x[1]):
            CLUSTER_A, CLUSTER_B = EDGE
            if LABELS[CLUSTER_A] == -1 and LABELS[CLUSTER_B] == -1:
                LABELS[CLUSTER_A] = CLUSTER_ID
                LABELS[CLUSTER_B] = CLUSTER_ID
                CLUSTER_ID += 1
            elif LABELS[CLUSTER_A] == -1:
                LABELS[CLUSTER_A] = LABELS[CLUSTER_B]
            elif LABELS[CLUSTER_B] == -1:
                LABELS[CLUSTER_B] = LABELS[CLUSTER_A]
            elif LABELS[CLUSTER_A] != LABELS[CLUSTER_B]:
                MERGE_LABEL = min(LABELS[CLUSTER_A], LABELS[CLUSTER_B])
                LABELS[np.logical_or(LABELS == LABELS[CLUSTER_A], LABELS == LABELS[CLUSTER_B])] = MERGE_LABEL
        return __POST_PROCESS_LABELS__(LABELS)

    def __POST_PROCESS_LABELS__(LABELS):
        UNIQUE_LABELS = np.unique(LABELS)
        NEW_LABELS = -1 * np.ones_like(LABELS)
        for IDX, LABEL in enumerate(UNIQUE_LABELS):
            NEW_LABELS[LABELS == LABEL] = IDX
        return NEW_LABELS

    N_SAMPLES = X.shape[0]
    CORE_DISTANCES = __COMPUTE_CORE_DISTANCES__(X)
    NEIGHBOURS = __COMPUTE_NEIGHBOURS__(X, CORE_DISTANCES)
    CONDENSED_TREE = __CONDENSE_TREE__(X, NEIGHBOURS, CORE_DISTANCES)
    LABELS = __EXTRACT_CLUSTERS__(CONDENSED_TREE, N_SAMPLES)
    return LABELS

# THE `PAIRWISE_DISTANCES` FUNCTION CALCULATES THE PAIRWISE DISTANCES BETWEEN A SET OF SAMPLES REPRESENTED BY A MATRIX `X`.
#     1. THE FUNCTION TAKES A SINGLE PARAMETER `X`, WHICH IS EXPECTED TO BE A NUMPY ARRAY REPRESENTING THE SAMPLES. EACH ROW IN `X` CORRESPONDS TO A SINGLE SAMPLE, AND THE COLUMNS REPRESENT DIFFERENT FEATURES OR DIMENSIONS OF THE SAMPLES.
#     2. `N_SAMPLES = X.SHAPE[0]` ASSIGNS THE NUMBER OF SAMPLES IN `X` TO THE VARIABLE `N_SAMPLES`. THIS VALUE IS USED TO DETERMINE THE SIZE OF THE RESULTING DISTANCE MATRIX.
#     3. `DISTANCES = NP.ZEROS((N_SAMPLES, N_SAMPLES))` CREATES AN EMPTY SQUARE MATRIX OF SIZE `N_SAMPLES` BY `N_SAMPLES` USING NUMPY'S `ZEROS` FUNCTION. THIS MATRIX WILL STORE THE PAIRWISE DISTANCES BETWEEN THE SAMPLES.
#     4. THE FUNCTION ENTERS A NESTED LOOP WITH THE OUTER LOOP ITERATING OVER THE RANGE OF `N_SAMPLES`. THE VARIABLE `I` REPRESENTS THE CURRENT ROW INDEX.
#     5. THE INNER LOOP ITERATES OVER THE RANGE FROM `I + 1` TO `N_SAMPLES`. THE VARIABLE `J` REPRESENTS THE CURRENT COLUMN INDEX.
#     6. INSIDE THE NESTED LOOP, `DISTANCES[I, J] = DISTANCES[J, I] = NP.LINALG.NORM(X[I] - X[J])` CALCULATES THE EUCLIDEAN DISTANCE BETWEEN THE `I`-TH AND `J`-TH SAMPLES. `NP.LINALG.NORM` COMPUTES THE NORM OF THE VECTOR DIFFERENCE `X[I] - X[J]`, WHICH REPRESENTS THE DISTANCE BETWEEN THE TWO SAMPLES. THE CALCULATED DISTANCE IS THEN ASSIGNED TO BOTH `DISTANCES[I, J]` AND `DISTANCES[J, I]` TO ENSURE THAT THE DISTANCE MATRIX IS SYMMETRIC.
#     7. AFTER THE NESTED LOOPS HAVE ITERATED OVER ALL PAIRS OF SAMPLES, THE FUNCTION RETURNS THE RESULTING DISTANCE MATRIX `DISTANCES`.
# IN SUMMARY, THE `PAIRWISE_DISTANCES` FUNCTION CALCULATES THE PAIRWISE DISTANCES BETWEEN SAMPLES BY COMPUTING THE EUCLIDEAN DISTANCE BETWEEN EACH PAIR OF SAMPLES AND STORING THE DISTANCES IN A SYMMETRIC MATRIX. THIS FUNCTION CAN BE USEFUL IN VARIOUS APPLICATIONS SUCH AS CLUSTERING, DIMENSIONALITY REDUCTION, OR SIMILARITY ANALYSIS.
def PAIRWISE_DISTANCES(X):
    """THE `PAIRWISE_DISTANCES` FUNCTION IS A PYTHON IMPLEMENTATION THAT CALCULATES THE PAIRWISE DISTANCES BETWEEN SAMPLES IN A GIVEN DATASET. IT UTILIZES THE NUMPY LIBRARY FOR EFFICIENT MATHEMATICAL OPERATIONS.
    THE FUNCTION TAKES A MATRIX `X` AS INPUT, WHERE EACH ROW REPRESENTS A SAMPLE AND THE COLUMNS CORRESPOND TO DIFFERENT FEATURES OR DIMENSIONS OF THE SAMPLES. IT INITIALIZES AN EMPTY DISTANCE MATRIX OF SIZE `N_SAMPLES` BY `N_SAMPLES`, WHERE `N_SAMPLES` IS THE NUMBER OF SAMPLES IN THE INPUT MATRIX.
    USING NESTED LOOPS, THE FUNCTION ITERATES OVER EACH PAIR OF SAMPLES, EXCLUDING SELF-PAIRS AND REDUNDANT COMPUTATIONS DUE TO SYMMETRY. FOR EACH PAIR, IT CALCULATES THE EUCLIDEAN DISTANCE BETWEEN THE SAMPLES USING THE `NP.LINALG.NORM` FUNCTION, WHICH CALCULATES THE NORM OF THE VECTOR DIFFERENCE. THE RESULTING DISTANCE IS STORED IN BOTH THE CORRESPONDING CELLS OF THE DISTANCE MATRIX TO ENSURE SYMMETRY.
    ONCE ALL PAIRWISE DISTANCES HAVE BEEN COMPUTED, THE FUNCTION RETURNS THE DISTANCE MATRIX, WHICH PROVIDES A COMPREHENSIVE REPRESENTATION OF THE DISTANCES BETWEEN ALL SAMPLES IN THE DATASET.
    THIS FUNCTION CAN BE VALUABLE IN VARIOUS APPLICATIONS SUCH AS CLUSTERING ALGORITHMS, WHERE KNOWING THE DISTANCES BETWEEN SAMPLES IS CRUCIAL FOR GROUPING SIMILAR SAMPLES TOGETHER. ADDITIONALLY, IT CAN BE USED IN DIMENSIONALITY REDUCTION TECHNIQUES OR SIMILARITY ANALYSIS, WHERE THE DISTANCES BETWEEN SAMPLES HELP QUANTIFY THE RELATIONSHIPS OR SIMILARITIES BETWEEN THEM."""
    N_SAMPLES = X.shape[0]
    DISTANCES = np.zeros((N_SAMPLES, N_SAMPLES))
    for i in range(N_SAMPLES):
        for j in range(i + 1, N_SAMPLES):
            DISTANCES[i, j] = DISTANCES[j, i] = np.linalg.norm(X[i] - X[j])
    return DISTANCES