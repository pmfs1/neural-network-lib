import numpy as np
import pandas as pd

# CATEGORICAL_NAIVE_BAYES: CLASS THAT IMPLEMENTS CATEGORICAL NAIVE BAYES MODEL
class CATEGORICAL_NAIVE_BAYES:
    # INITIALIZES THE CATEGORICAL NAIVE BAYES MODEL
    def __init__(self, ALPHA=1):
        self.ALPHA = ALPHA # ALPHA: HYPERPARAMETER THAT CONTROLS THE SMOOTHING OF THE MODEL.
        self.PROBABILITIES = dict() # PROBABILITIES: DICTIONARY THAT STORES THE PROBABILITIES OF EACH FEATURE.
        self.CONDITIONAL_PROBABILITIES = dict() # CONDITIONAL PROBABILITIES: DICTIONARY THAT STORES THE CONDITIONAL PROBABILITIES OF EACH FEATURE.
        self.TARGETS = list() # TARGETS: LIST THAT STORES THE UNIQUE TARGETS.
        self.COLUMNS = list() # COLUMNS: LIST THAT STORES THE COLUMN NAMES.
    
    # FIT(): TRAINS THE CATEGORICAL NAIVE BAYES MODEL
    def fit(self, X, Y, COLUMN_NAMES):
        DATASET = pd.DataFrame(data=X, index=None, columns=COLUMN_NAMES[:-1]) # DATASET: DATAFRAME THAT STORES THE DATASET.
        TARGET_COLUMN_NAME = COLUMN_NAMES[-1] # TARGET_COLUMN_NAME: STRING THAT STORES THE TARGET COLUMN NAME.
        DATASET[TARGET_COLUMN_NAME] = Y # ADDS THE TARGET COLUMN TO THE DATASET.
        for COLUMN in DATASET: # LOOP THAT ITERATES OVER THE COLUMNS OF THE DATASET.
            self.PROBABILITIES[COLUMN] = dict() # ADDS A NEW KEY TO THE PROBABILITIES DICTIONARY.
            for VALUE in DATASET[COLUMN].unique(): # LOOP THAT ITERATES OVER THE UNIQUE VALUES OF THE COLUMN.
                self.PROBABILITIES[COLUMN][VALUE] = (len(DATASET.query('{0} == @'.format(COLUMN))) + self.ALPHA) / (len(DATASET) + self.ALPHA * len(DATASET[COLUMN].unique())) # CALCULATES THE PROBABILITY OF THE VALUE: P(COLUMN = VALUE).
        for COLUMN in DATASET.drop([TARGET_COLUMN_NAME], axis=1): # LOOP THAT ITERATES OVER THE COLUMNS OF THE DATASET.
            self.CONDITIONAL_PROBABILITIES[COLUMN] = dict() # ADDS A NEW KEY TO THE CONDITIONAL_PROBABILITIES DICTIONARY.
            for VALUE1 in DATASET[COLUMN].unique(): # LOOP THAT ITERATES OVER THE UNIQUE VALUES OF THE COLUMN.
                for VALUE2 in DATASET[TARGET_COLUMN_NAME].unique(): # LOOP THAT ITERATES OVER THE UNIQUE VALUES OF THE TARGET COLUMN.
                    self.CONDITIONAL_PROBABILITIES[COLUMN][f'{VALUE1}-{VALUE2}'] = (len(DATASET.query('{0} == @VALUE1 and {1} == @VALUE2'.format(COLUMN, TARGET_COLUMN_NAME))) + self.ALPHA) / (len(DATASET.query('{0} == @VALUE2'.format(TARGET_COLUMN_NAME))) + self.ALPHA * len(DATASET[COLUMN].unique())) # CALCULATES THE CONDITIONAL PROBABILITY OF THE VALUE: P(COLUMN = VALUE1 | TARGET = VALUE2).
        self.TARGETS = DATASET[TARGET_COLUMN_NAME].unique() # STORES THE UNIQUE TARGETS.
        self.COLUMNS = COLUMN_NAMES # STORES THE COLUMN NAMES.
    
    # TRANSFORM(): PREDICTS THE TARGET OF THE GIVEN DATA.
    def TRANSFORM(self, X):
        HYPOTHESIS = list() # HYPOTHESIS: LIST THAT STORES THE HYPOTHESIS OF THE TARGETS.
        for ROW in X: # LOOP THAT ITERATES OVER THE ROWS OF THE DATA.
            TARGET_PROBABILITY_DICT = dict() # TARGET_PROBABILITY_DICT: DICTIONARY THAT STORES THE PROBABILITIES OF EACH TARGET.
            for TARGET in self.TARGETS: # LOOP THAT ITERATES OVER THE TARGETS.
                ROW_CONDITIONAL_PROBABILITIES = [ self.CONDITIONAL_PROBABILITIES[COLUMN][f'{VALUE}-{TARGET}'] for COLUMN, VALUE in zip(self.COLUMNS, ROW) ] # ROW_CONDITIONAL_PROBABILITIES: LIST THAT STORES THE CONDITIONAL PROBABILITIES OF EACH FEATURE.
                TARGET_PROBABILITY_DICT[TARGET] = (np.prod(ROW_CONDITIONAL_PROBABILITIES) * self.PROBABILITIES[self.COLUMNS[-1]][TARGET]) # CALCULATES THE PROBABILITY OF THE TARGET.
            HYPOTHESIS.append(max(TARGET_PROBABILITY_DICT, key=TARGET_PROBABILITY_DICT.get)) # APPENDS THE TARGET WITH THE HIGHEST PROBABILITY.
        return HYPOTHESIS # RETURNS THE HYPOTHESIS OF THE TARGETS.