import numpy as np
import pandas as pd

# CATEGORICAL_NAIVE_BAYES: CLASS THAT IMPLEMENTS CATEGORICAL NAIVE BAYES MODEL
class CATEGORICAL_NAIVE_BAYES:
    # INITIALIZES THE CATEGORICAL NAIVE BAYES MODEL
    def __init__(self, ALPHA=1):
        # ALPHA: HYPERPARAMETER THAT CONTROLS THE SMOOTHING OF THE MODEL.
        self.ALPHA = ALPHA
        # PROBABILITIES: DICTIONARY THAT STORES THE PROBABILITIES OF EACH FEATURE.
        self.PROBABILITIES = dict()
        # CONDITIONAL PROBABILITIES: DICTIONARY THAT STORES THE CONDITIONAL PROBABILITIES OF EACH FEATURE.
        self.CONDITIONAL_PROBABILITIES = dict()
        self.TARGETS = list()  # TARGETS: LIST THAT STORES THE UNIQUE TARGETS.
        self.COLUMNS = list()  # COLUMNS: LIST THAT STORES THE COLUMN NAMES.

    # FIT(): TRAINS THE CATEGORICAL NAIVE BAYES MODEL
    def fit(self, X, Y, COLUMN_NAMES):
        # DATASET: DATAFRAME THAT STORES THE DATASET.
        DATASET = pd.DataFrame(data=X, index=None, columns=COLUMN_NAMES[:-1])
        # TARGET_COLUMN_NAME: STRING THAT STORES THE TARGET COLUMN NAME.
        TARGET_COLUMN_NAME = COLUMN_NAMES[-1]
        # ADDS THE TARGET COLUMN TO THE DATASET.
        DATASET[TARGET_COLUMN_NAME] = Y
        for COLUMN in DATASET:  # LOOP THAT ITERATES OVER THE COLUMNS OF THE DATASET.
            # ADDS A NEW KEY TO THE PROBABILITIES DICTIONARY.
            self.PROBABILITIES[COLUMN] = dict()
            # LOOP THAT ITERATES OVER THE UNIQUE VALUES OF THE COLUMN.
            for VALUE in DATASET[COLUMN].unique():
                # CALCULATES THE PROBABILITY OF THE VALUE: P(COLUMN = VALUE).
                self.PROBABILITIES[COLUMN][VALUE] = (len(DATASET.query(
                    '{0} == @'.format(COLUMN))) + self.ALPHA) / (len(DATASET) + self.ALPHA * len(DATASET[COLUMN].unique()))
        # LOOP THAT ITERATES OVER THE COLUMNS OF THE DATASET.
        for COLUMN in DATASET.drop([TARGET_COLUMN_NAME], axis=1):
            # ADDS A NEW KEY TO THE CONDITIONAL_PROBABILITIES DICTIONARY.
            self.CONDITIONAL_PROBABILITIES[COLUMN] = dict()
            # LOOP THAT ITERATES OVER THE UNIQUE VALUES OF THE COLUMN.
            for VALUE1 in DATASET[COLUMN].unique():
                # LOOP THAT ITERATES OVER THE UNIQUE VALUES OF THE TARGET COLUMN.
                for VALUE2 in DATASET[TARGET_COLUMN_NAME].unique():
                    self.CONDITIONAL_PROBABILITIES[COLUMN][f'{VALUE1}-{VALUE2}'] = (len(DATASET.query('{0} == @VALUE1 and {1} == @VALUE2'.format(COLUMN, TARGET_COLUMN_NAME))) + self.ALPHA) / (len(DATASET.query(
                        '{0} == @VALUE2'.format(TARGET_COLUMN_NAME))) + self.ALPHA * len(DATASET[COLUMN].unique()))  # CALCULATES THE CONDITIONAL PROBABILITY OF THE VALUE: P(COLUMN = VALUE1 | TARGET = VALUE2).
        # STORES THE UNIQUE TARGETS.
        self.TARGETS = DATASET[TARGET_COLUMN_NAME].unique()
        self.COLUMNS = COLUMN_NAMES  # STORES THE COLUMN NAMES.

    # TRANSFORM(): PREDICTS THE TARGET OF THE GIVEN DATA.
    def TRANSFORM(self, X):
        # HYPOTHESIS: LIST THAT STORES THE HYPOTHESIS OF THE TARGETS.
        HYPOTHESIS = list()
        for ROW in X:  # LOOP THAT ITERATES OVER THE ROWS OF THE DATA.
            # TARGET_PROBABILITY_DICT: DICTIONARY THAT STORES THE PROBABILITIES OF EACH TARGET.
            TARGET_PROBABILITY_DICT = dict()
            for TARGET in self.TARGETS:  # LOOP THAT ITERATES OVER THE TARGETS.
                # ROW_CONDITIONAL_PROBABILITIES: LIST THAT STORES THE CONDITIONAL PROBABILITIES OF EACH FEATURE.
                ROW_CONDITIONAL_PROBABILITIES = [
                    self.CONDITIONAL_PROBABILITIES[COLUMN][f'{VALUE}-{TARGET}'] for COLUMN, VALUE in zip(self.COLUMNS, ROW)]
                # CALCULATES THE PROBABILITY OF THE TARGET.
                TARGET_PROBABILITY_DICT[TARGET] = (np.prod(
                    ROW_CONDITIONAL_PROBABILITIES) * self.PROBABILITIES[self.COLUMNS[-1]][TARGET])
            # APPENDS THE TARGET WITH THE HIGHEST PROBABILITY.
            HYPOTHESIS.append(max(TARGET_PROBABILITY_DICT,
                              key=TARGET_PROBABILITY_DICT.get))
        return HYPOTHESIS  # RETURNS THE HYPOTHESIS OF THE TARGETS.