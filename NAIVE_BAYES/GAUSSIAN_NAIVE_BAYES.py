import numpy as np
import pandas as pd

# GAUSSIAN_NAIVE_BAYES: CLASS THAT IMPLEMENTS GAUSSIAN NAIVE BAYES MODEL
class GAUSSIAN_NAIVE_BAYES:
    # INITIALIZES THE GAUSSIAN NAIVE BAYES MODEL
    def __init__(self, VAR_SMOOTHING=1e-9):
        # VAR_SMOOTHING: PORTION OF THE LARGEST VARIANCE OF ALL FEATURES THAT IS ADDED TO VARIANCES FOR CALCULATION STABILITY.
        self.VAR_SMOOTHING = VAR_SMOOTHING
        # SIGMAS: DICTIONARY THAT CONTAINS THE VARIANCES OF EACH FEATURE FOR EACH TARGET
        self.SIGMAS = dict()
        # DISPERSIONS: DICTIONARY THAT CONTAINS THE MEANS OF EACH FEATURE FOR EACH TARGET
        self.DISPERSIONS = dict()
        # PROBABILITIES: DICTIONARY THAT CONTAINS THE PROBABILITIES OF EACH TARGET
        self.PROBABILITIES = dict()
        self.TARGETS = list()  # TARGETS: LIST THAT CONTAINS THE TARGETS OF THE DATASET
        self.COLUMNS = list()  # COLUMNS: LIST THAT CONTAINS THE COLUMNS OF THE DATASET

    # FIT(): TRAINS THE GUASSIAN NAIVE BAYES MODEL
    def FIT(self, X, Y, COLUMN_NAMES):
        # DATASET: DATAFRAME THAT CONTAINS THE FEATURES OF THE DATASET
        DATASET = pd.DataFrame(data=X, index=None, columns=COLUMN_NAMES[:-1])
        # TARGET_COLUMN_NAME: STRING THAT CONTAINS THE NAME OF THE TARGET COLUMN
        TARGET_COLUMN_NAME = COLUMN_NAMES[-1]
        # ADDS THE TARGET COLUMN TO THE DATASET
        DATASET[TARGET_COLUMN_NAME] = Y
        # ITERATES OVER THE COLUMNS OF THE DATASET
        for COLUMN in DATASET.drop(TARGET_COLUMN_NAME, axis=1):
            # INITIALIZES THE SIGMAS DICTIONARY FOR THE CURRENT COLUMN
            self.SIGMAS[COLUMN] = dict()
            # INITIALIZES THE DISPERSIONS DICTIONARY FOR THE CURRENT COLUMN
            self.DISPERSIONS[COLUMN] = dict()
            # ITERATES OVER THE TARGETS OF THE DATASET
            for TARGET in DATASET[TARGET_COLUMN_NAME].unique():
                # SAMPLE: ARRAY THAT CONTAINS THE VALUES OF THE CURRENT COLUMN FOR THE CURRENT TARGET
                SAMPLE = np.array(DATASET.query(
                    '{0} == @TARGET'.format(TARGET_COLUMN_NAME))[COLUMN])
                # CALCULATES THE VARIANCE OF THE CURRENT COLUMN FOR THE CURRENT TARGET
                self.SIGMAS[COLUMN][TARGET] = SAMPLE.std(
                ) + self.VAR_SMOOTHING * SAMPLE.std()
                # CALCULATES THE MEAN OF THE CURRENT COLUMN FOR THE CURRENT TARGET
                self.DISPERSIONS[COLUMN][TARGET] = SAMPLE.mean()
                # CALCULATES THE PROBABILITIES OF THE CURRENT TARGET
                self.PROBABILITIES[COLUMN] = len(SAMPLE) / len(X)
        # SAVES THE TARGETS OF THE DATASET
        self.TARGETS = DATASET[TARGET_COLUMN_NAME].unique()
        self.COLUMNS = COLUMN_NAMES  # SAVES THE COLUMNS OF THE DATASET

    # TRANSFORM(): PREDICTS THE TARGETS OF THE GIVEN DATASET
    def TRANSFORM(self, X):
        # HYPOTHESIS: LIST THAT CONTAINS THE PREDICTED TARGETS OF THE GIVEN DATASET
        HYPOTHESIS = list()
        for ROW in X:  # ITERATES OVER THE ROWS OF THE GIVEN DATASET
            # TARGET_PROBABILITIES_DICT: DICTIONARY THAT CONTAINS THE PROBABILITIES OF EACH TARGET FOR THE CURRENT ROW
            TARGET_PROBABILITIES_DICT = dict()
            for TARGET in self.TARGETS:  # ITERATES OVER THE TARGETS OF THE DATASET
                # ITERATES OVER THE FEATURES OF THE CURRENT ROW
                for X, COLUMN in zip(ROW, self.COLUMNS[:-1]):
                    # SIGMA: FLOAT THAT CONTAINS THE VARIANCE OF THE CURRENT FEATURE FOR THE CURRENT TARGET
                    SIGMA = self.SIGMAS[COLUMN][TARGET]
                    # DISPERSION: FLOAT THAT CONTAINS THE MEAN OF THE CURRENT FEATURE FOR THE CURRENT TARGET
                    DISPERSION = self.DISPERSIONS[COLUMN][TARGET]
                    # PROBABILITY: FLOAT THAT CONTAINS THE PROBABILITY OF THE CURRENT TARGET
                    PROBABILITY = self.PROBABILITIES[COLUMN]
                    # TARGET_PROBABILITY: FLOAT THAT CONTAINS THE PROBABILITY OF THE CURRENT TARGET FOR THE CURRENT FEATURE
                    TARGET_PROBABILITY = ((1 / np.sqrt(np.pi * SIGMA)) * np.exp(-(
                        (X - DISPERSION) ** 2 / (2 * SIGMA ** 2)))) * PROBABILITY
                    # UPDATES THE PROBABILITY OF THE CURRENT TARGET FOR THE CURRENT ROW
                    TARGET_PROBABILITIES_DICT[TARGET] = TARGET_PROBABILITIES_DICT.get(
                        TARGET, 1) * TARGET_PROBABILITY
            # APPENDS THE TARGET WITH THE HIGHEST PROBABILITY FOR THE CURRENT ROW
            HYPOTHESIS.append(max(TARGET_PROBABILITIES_DICT,
                              key=TARGET_PROBABILITIES_DICT.get))
        return HYPOTHESIS  # RETURNS THE PREDICTED TARGETS OF THE GIVEN DATASET