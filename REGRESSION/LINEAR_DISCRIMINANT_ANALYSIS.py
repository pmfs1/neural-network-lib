import numpy as np
from numpy.linalg import multi_dot
from numpy.linalg import inv

# LINEAR_DISCRIMINANT_ANALYSIS: IMPLEMENTS LINEAR DISCRIMINANT ANALYSIS MODEL. LINEAR DISCRIMINANT ANALYSIS (LDA) IS A STATISTICAL METHOD USED TO FIND A LINEAR COMBINATION OF FEATURES THAT CHARACTERIZES OR SEPARATES TWO OR MORE CLASSES OF OBJECTS OR EVENTS. IT IS A DISCRIMINANT APPROACH THAT ATTEMPTS TO MODEL DIFFERENCES AMONG SAMPLES ASSIGNED TO CERTAIN GROUPS. THE AIM OF THE METHOD IS TO MAXIMIZE THE RATIO OF THE BETWEEN-GROUP VARIANCE AND THE WITHIN-GROUP VARIANCE.
class LINEAR_DISCRIMINANT_ANALYSIS:
    # INITIALIZES THE LINEAR DISCRIMINANT ANALYSIS MODEL
    def __init__(self):
        # VARIANCE: THE VARIANCE OF THE LINEAR DISCRIMINANT ANALYSIS MODEL; MEANING THE VARIANCE OF THE DATA
        self.VARIANCE = None
        # ESTIMATES: THE ESTIMATES OF THE LINEAR DISCRIMINANT ANALYSIS MODEL; MEANING THE ESTIMATES OF THE CLASSES; EACH ESTIMATE IS A TUPLE OF THE FORM (CLASS, PROBABILITY, MEAN, VARIANCE)
        self.ESTIMATES = None

    # FIT: FITS THE LINEAR DISCRIMINANT ANALYSIS MODEL TO THE TRAINING DATA
    def FIT(self, X, Y):
        CLASSES = list(np.unique(Y)) # GET THE UNIQUE CLASSES
        ESTIMATES = [] # INITIALIZE THE ESTIMATES LIST
        VARIANCE = 0 # INITIALIZE THE VARIANCE ESTIMATE
        for _C in CLASSES: # ITERATE THROUGH THE CLASSES
            ESTIMATE = [] # INITIALIZE THE ESTIMATE LIST
            ESTIMATE.append(_C) # ADD THE CLASS TO THE ESTIMATE LIST
            IDX_ROWS = np.where(np.isin(Y,_C)) # GET THE INDICES OF THE ROWS WHERE THE CLASS IS PRESENT
            X_SUBSET = X[IDX_ROWS] # GET THE SUBSET OF THE DATA WHERE THE CLASS IS PRESENT
            PI = float(len(X_SUBSET))/float(len(X)) # COMPUTE THE PROBABILITY OF THE CLASS
            ESTIMATE.append(PI) # ADD THE PROBABILITY OF THE CLASS TO THE ESTIMATE LIST
            MEAN = (np.sum(X_SUBSET,axis=0) / float(len(X_SUBSET))).reshape(-1,1) # COMPUTE THE MEAN OF THE CLASS
            ESTIMATE.append(MEAN) # ADD THE MEAN OF THE CLASS TO THE ESTIMATE LIST
            VARIANCE = (1./(len(X_SUBSET) - len(CLASSES))) * (sum([(ROW.reshape(-1,1) - MEAN).dot((ROW.reshape(-1,1) - MEAN).T) for ROW in X_SUBSET])) # COMPUTE THE VARIANCE OF THE CLASS
            ESTIMATE.append(VARIANCE) # ADD THE VARIANCE OF THE CLASS TO THE ESTIMATE LIST
            ESTIMATES.append(tuple(ESTIMATE)) # ADD THE ESTIMATE TO THE ESTIMATES LIST
            VARIANCE = sum([ESTIMATE[3] for ESTIMATE in ESTIMATES]) # COMPUTE THE VARIANCE OF THE DATA
        self.ESTIMATES = ESTIMATES # SET THE ESTIMATES OF THE LINEAR DISCRIMINANT ANALYSIS MODEL
        self.VARIANCE = VARIANCE # SET THE VARIANCE OF THE LINEAR DISCRIMINANT ANALYSIS MODEL

    # PREDICT: PREDICTS THE CLASS OF THE DATA
    def PREDICT(self, X):
        assert self.ESTIMATES is not None and self.VARIANCE is not None, "FIT MUST BE CALLED BEFORE PREDICT" # ENSURE THAT FIT HAS BEEN CALLED
        BAYES_PROBABILITIES = [] # INITIALIZE THE BAYES PROBABILITIES LIST
        for ESTIMATE in self.ESTIMATES: # ITERATE THROUGH THE ESTIMATES
            PI = ESTIMATE[1] # GET THE PROBABILITY OF THE CLASS
            MEAN = ESTIMATE[2] # GET THE MEAN OF THE CLASS
            SIGMA_INV = inv(self.VARIANCE) # GET THE INVERSE OF THE VARIANCE OF THE CLASS
            BAYES_PROBABILITY = multi_dot([X,SIGMA_INV,MEAN]) - (.5 * multi_dot([MEAN.T,SIGMA_INV,MEAN])) + np.log(PI) # COMPUTE THE BAYES PROBABILITY OF THE CLASS
            BAYES_PROBABILITIES.append(BAYES_PROBABILITY) # ADD THE BAYES PROBABILITY TO THE BAYES PROBABILITIES LIST
        BAYES_PROBABILITIES = BAYES_PROBABILITIES # SET THE BAYES PROBABILITIES OF THE LINEAR DISCRIMINANT ANALYSIS MODEL
        IDXS_OF_HIGHEST_PROB = np.argmax(np.concatenate(BAYES_PROBABILITIES,axis=1),axis=1) # GET THE INDICES OF THE HIGHEST PROBABILITIES
        # def PREDICT_CLASS(INDEX): # DEFINE THE PREDICT CLASS FUNCTION
        #     return self.ESTIMATES[INDEX][0] # RETURN THE CLASS OF THE ESTIMATE
        # PREDICT_CLASS_VEC = np.vectorize(PREDICT_CLASS) # CREATE A FUNCTION THAT DOES THIS TO A VECTOR
        # PREDICTIONS = PREDICT_CLASS_VEC(IDXS_OF_HIGHEST_PROB) # GET THE PREDICTIONS
        # return PREDICTIONS # RETURN THE PREDICTIONS
        PREDICTIONS = [self.ESTIMATES[IDX][0] for IDX in IDXS_OF_HIGHEST_PROB] # GET THE PREDICTIONS
        return np.array(PREDICTIONS) # RETURN THE PREDICTIONS