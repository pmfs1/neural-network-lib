import math

# TODO: CHECK IF BETA BINOMIAL DISTRIBUTION IS CORRECT
# BETA_BINOMIAL_DISTRIBUTION: IMPLEMENTATION OF BETA BINOMIAL DISTRIBUTION. THE BETA-BINOMIAL DISTRIBUTION, WHICH DESCRIBES THE NUMBER OF SUCCESSES IN A SERIES OF INDEPENDENT YES/NO EXPERIMENTS WITH HETEROGENEITY IN THE SUCCESS PROBABILITY.
class BETA_BINOMIAL_DISTRIBUTION:
    # PROBABILITY_MASS_FUNCTION [STATIC]: IN PROBABILITY AND STATISTICS, A PROBABILITY MASS FUNCTION IS A FUNCTION THAT GIVES THE PROBABILITY THAT A DISCRETE RANDOM VARIABLE IS EXACTLY EQUAL TO SOME VALUE. THE PROBABILITY MASS FUNCTION IS OFTEN THE PRIMARY MEANS OF DEFINING A DISCRETE PROBABILITY DISTRIBUTION, AND SUCH FUNCTIONS EXIST FOR EITHER DISCRETE RANDOM VARIABLES OR CONTINUOUS RANDOM VARIABLES WHOSE CUMULATIVE DISTRIBUTION FUNCTION IS DISCONTINUOUS. THE PROBABILITY MASS FUNCTION IS SOMETIMES ALSO CALLED THE PROBABILITY FUNCTION, OR THE PROBABILITY DISTRIBUTION FUNCTION.
    @staticmethod
    def PROBABILITY_MASS_FUNCTION(K: int, N: int, ALPHA: float, BETA: float) -> float:
        assert ALPHA >= 0, "ALPHA MUST BE GREATER THAN OR EQUAL TO 0" # ASSERT ALPHA IS GREATER THAN OR EQUAL TO 0
        assert BETA >= 0, "BETA MUST BE GREATER THAN OR EQUAL TO 0" # ASSERT BETA IS GREATER THAN OR EQUAL TO 0
        assert K >= 0 and K <= N, "K MUST BE GREATER THAN OR EQUAL TO 0 AND LESS THAN OR EQUAL TO N" # ASSERT K IS GREATER THAN OR EQUAL TO 0 AND LESS THAN OR EQUAL TO N
        return (math.factorial(N) / (math.factorial(K) * math.factorial(N - K))) * (BETA_BINOMIAL_DISTRIBUTION.__BETA_BINOMIAL_COEFFICIENT__(K, N, ALPHA, BETA) / BETA_BINOMIAL_DISTRIBUTION.__BETA_BINOMIAL_COEFFICIENT__(N, N, ALPHA, BETA)) # RETURN (N CHOOSE K) * BETA_BINOMIAL_COEFFICIENT(K, N, ALPHA, BETA) / BETA_BINOMIAL_COEFFICIENT(N, N, ALPHA, BETA)
    
    # CUMULATIVE_DISTRIBUTION_FUNCTION [STATIC]: IN PROBABILITY THEORY AND STATISTICS, THE CUMULATIVE DISTRIBUTION FUNCTION (CDF) OF A REAL-VALUED RANDOM VARIABLE X, OR JUST DISTRIBUTION FUNCTION OF X, EVALUATED AT X, IS THE PROBABILITY THAT X WILL TAKE A VALUE LESS THAN OR EQUAL TO X.
    @staticmethod
    def CUMULATIVE_DISTRIBUTION_FUNCTION(K: int, N: int, ALPHA: float, BETA: float) -> float:
        assert ALPHA >= 0, "ALPHA MUST BE GREATER THAN OR EQUAL TO 0" # ASSERT ALPHA IS GREATER THAN OR EQUAL TO 0
        assert BETA >= 0, "BETA MUST BE GREATER THAN OR EQUAL TO 0" # ASSERT BETA IS GREATER THAN OR EQUAL TO 0
        assert K >= 0 and K <= N, "K MUST BE GREATER THAN OR EQUAL TO 0 AND LESS THAN OR EQUAL TO N" # ASSERT K IS GREATER THAN OR EQUAL TO 0 AND LESS THAN OR EQUAL TO N
        return sum([(math.factorial(N) / (math.factorial(i) * math.factorial(N - i))) * (BETA_BINOMIAL_DISTRIBUTION.__BETA_BINOMIAL_COEFFICIENT__(i, N, ALPHA, BETA) / BETA_BINOMIAL_DISTRIBUTION.__BETA_BINOMIAL_COEFFICIENT__(N, N, ALPHA, BETA)) for i in range(math.floor(K))]) # RETURN SUM OF PROBABILITY MASS FUNCTION FROM 0 TO K
    
    # BETA_BINOMIAL_COEFFICIENT [STATIC]: IN PROBABILITY THEORY AND STATISTICS, THE BETA BINOMIAL COEFFICIENT IS A GENERALIZATION OF THE BINOMIAL COEFFICIENT. THE BETA BINOMIAL COEFFICIENT IS DEFINED AS (N CHOOSE K) * (BETA_BINOMIAL_COEFFICIENT(K, N, ALPHA, BETA) / BETA_BINOMIAL_COEFFICIENT(N, N, ALPHA, BETA)).
    @staticmethod
    def __BETA_BINOMIAL_COEFFICIENT__(K: int, N: int, ALPHA: float, BETA: float) -> float:
        return (math.factorial(N) / (math.factorial(K) * math.factorial(N - K))) * (math.gamma(K + ALPHA) * math.gamma(N - K + BETA) * math.gamma(ALPHA + BETA) / math.gamma(N + ALPHA + BETA)) / (math.gamma(ALPHA) * math.gamma(BETA)) # RETURN BETA BINOMIAL COEFFICIENT