import numpy as np

# SUPPORT_VECTOR_MACHINE: CLASS THAT IMPLEMENTS SUPPORT VECTOR MACHINE MODEL
class SUPPORT_VECTOR_MACHINE:
    # INITIALIZES THE SUPPORT VECTOR MACHINE MODEL
    def __init__(self, LEARNING_RATE=0.001, LAMBDA=0.01, N_ITERS=1000):
        # LEARNING_RATE: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE LEARNING RATE.
        self.LEARNING_RATE = LEARNING_RATE
        # LAMBDA: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE REGULARIZATION STRENGTH.
        self.LAMBDA = LAMBDA
        # N_ITERS: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF ITERATIONS.
        self.N_ITERS = N_ITERS
        self.WEIGHTS = None  # WEIGHTS: IT'S THE WEIGHTS OF THE MODEL.
        self.BIAS = None  # BIAS: IT'S THE BIAS OF THE MODEL.

    # FIT(): METHOD THAT TRAINS THE SUPPORT VECTOR MACHINE MODEL
    def FIT(self, X, Y):
        # NUMBER OF TRAINING EXAMPLES AND NUMBER OF FEATURES
        _, NUMBER_OF_FEATURES = X.shape
        # _Y: IT'S THE ARRAY THAT CONTAINS THE CLASS LABELS OF THE DATASET.
        _Y = np.where(Y <= 0, -1, 1)
        # WEIGHTS: IT'S THE WEIGHTS OF THE MODEL.
        self.WEIGHTS = np.zeros(NUMBER_OF_FEATURES)
        self.BIAS = 0  # BIAS: IT'S THE BIAS OF THE MODEL.
        for _ in range(self.N_ITERS):  # ITERATES OVER THE NUMBER OF ITERATIONS
            # ITERATES OVER THE TRAINING EXAMPLES
            for INDEX_LENGTH, X_I in enumerate(X):
                # IF THE CONDITION IS SATISFIED
                if _Y[INDEX_LENGTH] * (np.dot(X_I, self.WEIGHTS) - self.BIAS) >= 1:
                    # UPDATES THE WEIGHTS: WEIGHTS = WEIGHTS - LEARNING_RATE * (2 * LAMBDA * WEIGHTS)
                    self.WEIGHTS -= self.LEARNING_RATE * \
                        (2 * self.LAMBDA * self.WEIGHTS)
                else:  # IF THE CONDITION IS NOT SATISFIED
                    # UPDATES THE WEIGHTS: WEIGHTS = WEIGHTS - LEARNING_RATE * (2 * LAMBDA * WEIGHTS - X[I] * Y[I])
                    self.WEIGHTS -= self.LEARNING_RATE * \
                        (2 * self.LAMBDA * self.WEIGHTS -
                         np.dot(X_I, _Y[INDEX_LENGTH]))
                    # UPDATES THE BIAS: BIAS = BIAS - LEARNING_RATE * Y[INDEX_LENGTH]
                    self.BIAS -= self.LEARNING_RATE * _Y[INDEX_LENGTH]

    # PREDICT(): METHOD THAT PREDICTS THE DATASET
    def PREDICT(self, X):
        # RETURNS THE PREDICTED DATASET: X * WEIGHTS - BIAS
        return np.sign(np.dot(X, self.WEIGHTS) - self.BIAS)