import math
import numpy as np

from .CSP import CSP

# SIMULATED_ANNEALING(): RUNS THE SIMULATED ANNEALING ALGORITHM IN ORDER TO FIND A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM. RETURNS THE CURRENT STATE IF A SOLUTION IS FOUND, OTHERWISE RETURNS FALSE.


def SIMULATED_ANNEALING(CSP_PROBLEM: CSP):
    """RUNS THE SIMULATED ANNEALING ALGORITHM IN ORDER TO FIND A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM. RETURNS THE CURRENT STATE IF A SOLUTION IS FOUND, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    CURRENT_STATE : DICTIONARY
        THE CURRENT STATE. IT REPRESENTS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM.
    """
    # INITIALIZE THE CURRENT STATE WITH A RANDOM ASSIGNMENT OF VALUES TO THE VARIABLES.
    CURRENT_STATE = {}
    for VARIABLE in CSP_PROBLEM.VARIABLES:
        CURRENT_STATE[VARIABLE] = np.random.choice(
            CSP_PROBLEM.DOMAINS[VARIABLE])
    # INITIALIZE THE TEMPERATURE.
    TEMPERATURE = 100
    # INITIALIZE THE COOLING RATE.
    COOLING_RATE = 0.99
    # WHILE THE TEMPERATURE IS GREATER THAN 1, ITERATE.
    while TEMPERATURE > 1:
        # INITIALIZE THE NEXT STATE WITH A RANDOM ASSIGNMENT OF VALUES TO THE VARIABLES.
        NEXT_STATE = {}
        for VARIABLE in CSP_PROBLEM.VARIABLES:
            NEXT_STATE[VARIABLE] = np.random.choice(
                CSP_PROBLEM.DOMAINS[VARIABLE])
        # IF THE NEXT STATE IS BETTER THAN THE CURRENT STATE, THEN THE NEXT STATE BECOMES THE CURRENT STATE.
        if __COST_FUNCTION__(CSP_PROBLEM, NEXT_STATE) < __COST_FUNCTION__(CSP_PROBLEM, CURRENT_STATE):
            CURRENT_STATE = NEXT_STATE
        # OTHERWISE, IF THE NEXT STATE IS NOT BETTER THAN THE CURRENT STATE, THEN THE NEXT STATE BECOMES THE CURRENT STATE WITH A PROBABILITY THAT DEPENDS ON THE TEMPERATURE.
        else:
            # CALCULATE THE PROBABILITY THAT THE NEXT STATE BECOMES THE CURRENT STATE.
            PROBABILITY = math.exp(- (__COST_FUNCTION__(CSP_PROBLEM, NEXT_STATE) -
                                   __COST_FUNCTION__(CSP_PROBLEM, CURRENT_STATE)) / TEMPERATURE)
            # IF THE PROBABILITY IS GREATER THAN A RANDOM NUMBER BETWEEN 0 AND 1, THEN THE NEXT STATE BECOMES THE CURRENT STATE.
            if PROBABILITY > np.random.uniform(0, 1):
                CURRENT_STATE = NEXT_STATE
        # COOL THE TEMPERATURE.
        TEMPERATURE *= COOLING_RATE
    # RETURN TRUE IF THE CURRENT STATE IS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM, OTHERWISE RETURN FALSE.
    return CURRENT_STATE

# __COST_FUNCTION__() [PRIVATE FUNCTION]: CALCULATES THE COST OF A STATE. THE COST OF A STATE IS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.


def __COST_FUNCTION__(CSP_PROBLEM: CSP, STATE):
    """[PRIVATE FUNCTION]: CALCULATES THE COST OF A STATE. THE COST OF A STATE IS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    STATE : DICTIONARY
        THE STATE. IT REPRESENTS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    COST : INTEGER
        THE COST OF THE STATE. IT IS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
    """
    # INITIALIZE THE COST.
    COST = 0
    # FOR EACH CONSTRAINT, CHECK IF THE CONSTRAINT IS SATISFIED BY THE STATE.
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED BY THE STATE, INCREASE THE COST BY 1.
        if not __CONSTRAINT_SATISFIED__(CONSTRAINT, STATE):
            COST += 1
    # RETURN THE COST.
    return COST

# __CONSTRAINT_SATISFIED__() [PRIVATE FUNCTION]: CHECKS IF A CONSTRAINT IS SATISFIED BY A STATE. THE CONSTRAINT IS SATISFIED IF THE PAIR OF VARIABLES IN THE CONSTRAINT HAVE DIFFERENT VALUES IN THE STATE.


def __CONSTRAINT_SATISFIED__(CONSTRAINT, STATE):
    """[PRIVATE FUNCTION]: CHECKS IF A CONSTRAINT IS SATISFIED BY A STATE. THE CONSTRAINT IS SATISFIED IF THE PAIR OF VARIABLES IN THE CONSTRAINT HAVE DIFFERENT VALUES IN THE STATE.

    PARAMETERS
    ----------
    CONSTRAINT : TUPLE
        THE CONSTRAINT. IT IS A TUPLE OF TWO VARIABLES.
    STATE : DICTIONARY
        THE STATE. IT REPRESENTS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE PAIR OF VARIABLES IN THE CONSTRAINT HAVE DIFFERENT VALUES IN THE STATE, OTHERWISE FALSE.
    """
    # RETURN TRUE IF THE PAIR OF VARIABLES IN THE CONSTRAINT HAVE DIFFERENT VALUES IN THE STATE, OTHERWISE RETURN FALSE.
    return STATE[CONSTRAINT[0]] != STATE[CONSTRAINT[1]]
