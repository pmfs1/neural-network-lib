from .CSP import CSP

# AC3(): RUNS THE AC-3 ALGORITHM. RETURNS FALSE IF AN INCONSISTENCY IS FOUND, OTHERWISE RETURNS TRUE.


def AC3(CSP_PROBLEM: CSP):
    """RUNS THE AC-3 ALGORITHM. RETURNS FALSE IF AN INCONSISTENCY IS FOUND, OTHERWISE RETURNS TRUE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CSP PROBLEM.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE CSP PROBLEM IS CONSISTENT, OTHERWISE FALSE.
    """
    QUEUE = []  # QUEUE, QUEUE OF ARCS, INITIALLY ALL THE ARCS IN THE PROBLEM.
    # FOR EACH VARIABLE, FIND THE NEIGHBORS OF THE VARIABLE.
    for VARIABLE in CSP_PROBLEM.VARIABLES:
        # FOR EACH NEIGHBOR OF THE VARIABLE, ADD THE ARC (VARIABLE, NEIGHBOR) TO THE QUEUE.
        for NEIGHBOR in CSP_PROBLEM.NEIGHBORS[VARIABLE]:
            # ADD THE ARC (VARIABLE, NEIGHBOR) TO THE QUEUE.
            QUEUE.append((VARIABLE, NEIGHBOR))
    # WHILE THE QUEUE IS NOT EMPTY, POP THE FIRST ARC (X_I, X_J) FROM THE QUEUE.
    while len(QUEUE) > 0:
        # POP THE FIRST ARC (X_I, X_J) FROM THE QUEUE.
        (X_I, X_J) = QUEUE.pop(0)
        # IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, DO THE FOLLOWING:
        if __REVISE__(CSP_PROBLEM, X_I, X_J):
            # IF THE DOMAIN OF THE VARIABLE X_I IS EMPTY, RETURN FALSE.
            if len(CSP_PROBLEM.DOMAINS[X_I]) == 0:
                return False  # RETURN FALSE.
            # FOR EACH X_K IN NEIGHBOURS MINUS X_J, ADD THE (X_K, X_I) TO THE QUEUE.
            for X_K in CSP_PROBLEM.NEIGHBORS[X_I]:
                # IF X_K IS DIFERENT THAN X_J, ADD THE (X_K, X_I) TO THE QUEUE.
                if X_K != X_J:
                    # ADD THE (X_K, X_I) TO THE QUEUE.
                    QUEUE.append((X_K, X_I))
    return True  # RETURNS TRUE.

# __REVISE__(): [PRIVATE FUNCTION] REVISES THE DOMAINS OF THE VARIABLE X_I, GIVEN THE DOMAINS OF THE VARIABLE X_J. RETURNS TRUE IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, OTHERWISE RETURNS FALSE.


def __REVISE__(CSP_PROBLEM: CSP, X_I, X_J):
    """[PRIVATE FUNCTION] REVISES THE DOMAINS OF THE VARIABLE X_I, GIVEN THE DOMAINS OF THE VARIABLE X_J. RETURNS TRUE IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CSP PROBLEM.
    X_I : STRING
        THE VARIABLE X_I.
    X_J : STRING
        THE VARIABLE X_J.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, OTHERWISE FALSE.
    """
    # REVISED, BOOLEAN, INDICATES IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED.
    REVISED = False
    # FOR EACH VALUE X OF THE DOMAIN OF THE VARIABLE X_I, CHECK IF THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
    for X in CSP_PROBLEM.DOMAINS[X_I]:
        # SATISFIED, BOOLEAN, INDICATES IF THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
        SATISFIED = False
        # FOR EACH VALUE Y OF THE DOMAIN OF THE VARIABLE X_J, CHECK IF THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
        for Y in CSP_PROBLEM.DOMAINS[X_J]:
            # IF THE VALUE X DOES NOT SATISFY THE CONSTRAINT (X_I, X_J), REMOVE THE VALUE X FROM THE DOMAIN OF THE VARIABLE X_I.
            if X != Y:
                # THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
                SATISFIED = True
                break  # BREAK THE LOOP.
        # IF THERE'S NO VALUE Y OF THE DOMAIN OF THE VARIABLE X_J THAT ALLOWS (X, Y) TO SATISFY THE CONSTRAINT BETWEEN (X_I, X_J), REMOVE THE VALUE X FROM THE DOMAIN OF THE VARIABLE X_I.
        if not SATISFIED:
            # REMOVE THE VALUE X FROM THE DOMAIN OF THE VARIABLE X_I.
            del CSP_PROBLEM.DOMAINS[X_I][CSP_PROBLEM.DOMAINS[X_I].index(X)]
            REVISED = True  # THE DOMAINS OF THE VARIABLE X_I ARE REVISED.
    return REVISED  # RETURN THE BOOLEAN REVISED.
