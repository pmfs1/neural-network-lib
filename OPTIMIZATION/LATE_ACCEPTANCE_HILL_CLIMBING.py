from .CSP import CSP
import random

# LATE_ACCEPTANCE_HILL_CLIMBING(): RETURNS THE SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM.


def LATE_ACCEPTANCE_HILL_CLIMBING(CSP_PROBLEM: CSP, MAX_ITERATIONS: int, LAHC_MEMORY_LENGTH: int):
    """RETURNS THE SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    MAX_ITERATIONS : INTEGER
        THE MAXIMUM NUMBER OF ITERATIONS.
    LAHC_MEMORY_LENGTH : INTEGER
        THE LENGTH OF THE LAHC MEMORY.

    RETURNS
    -------
    STATE : DICTIONARY
        THE SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM. IT CAN BE THE BEST STATE OR THE CURRENT STATE.
    """
    CURRENT_STATE = __GENERATE_RANDOM_STATE__(CSP_PROBLEM)
    BEST_STATE = CURRENT_STATE
    LAHC_LIST = [BEST_STATE]
    # FOR EACH ITERATION IN THE MAXIMUM NUMBER OF ITERATIONS, DO THE FOLLOWING:
    for ITERATION in range(MAX_ITERATIONS):
        # RANDOM_INDEX, INTEGER, THE RANDOM INDEX.
        RANDOM_INDEX = __GET_RANDOM_INDEX__(CSP_PROBLEM, ITERATION)
        # RANDOM_VARIABLE, VARIABLE, THE RANDOM VARIABLE.
        RANDOM_VARIABLE = CSP_PROBLEM.VARIABLES[RANDOM_INDEX]
        # RANDOM_VALUE, VALUE, THE RANDOM VALUE.
        RANDOM_VALUE = __SELECT_VALUE__(
            CSP_PROBLEM, CURRENT_STATE, RANDOM_VARIABLE)
        # ASSIGN THE RANDOM VALUE TO THE RANDOM VARIABLE.
        CURRENT_STATE[RANDOM_VARIABLE] = RANDOM_VALUE
        # IF THE ASSIGNMENT IS COMPLETE, RETURN THE ASSIGNMENT.
        if __COMPLETE__(CSP_PROBLEM, CURRENT_STATE):
            return CURRENT_STATE  # RETURN THE ASSIGNMENT.
        # IF THE CURRENT STATE IS BETTER THAN THE BEST STATE, DO THE FOLLOWING:
        if __BETTER__(CSP_PROBLEM, CURRENT_STATE, BEST_STATE):
            # BEST STATE, STATE, THE BEST STATE.
            BEST_STATE = CURRENT_STATE
        # APPEND THE BEST STATE TO THE LAHC LIST.
        LAHC_LIST.append(BEST_STATE)
        # IF THE ITERATION IS GREATER THAN OR EQUAL TO THE LAHC MEMORY LENGTH, DO THE FOLLOWING:
        if ITERATION >= LAHC_MEMORY_LENGTH:
            # CURRENT STATE, STATE, THE CURRENT STATE.
            CURRENT_STATE = LAHC_LIST[ITERATION - LAHC_MEMORY_LENGTH]
    return BEST_STATE  # RETURN THE BEST STATE.

# __GENERATE_RANDOM_STATE__(): [PRIVATE FUNCTION] RETURNS A RANDOM STATE.


def __GENERATE_RANDOM_STATE__(CSP_PROBLEM: CSP):
    """RETURNS A RANDOM STATE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    STATE : DICTIONARY
        A RANDOM STATE.
    """
    # STATE, DICTIONARY, THE STATE.
    STATE = {}
    # FOR EACH VARIABLE IN THE VARIABLES, DO THE FOLLOWING:
    for VARIABLE in CSP_PROBLEM.VARIABLES:
        # VALUES, LIST, THE VALUES.
        VALUES = CSP_PROBLEM.DOMAINS[VARIABLE]
        # RANDOM_VALUE, VALUE, THE RANDOM VALUE.
        RANDOM_VALUE = random.choice(VALUES)
        # STATE AT VARIABLE IS RANDOM VALUE.
        STATE[VARIABLE] = RANDOM_VALUE
    return STATE  # RETURN THE STATE.

# __GET_RANDOM_INDEX__(): [PRIVATE FUNCTION] RETURNS A RANDOM INDEX.


def __GET_RANDOM_INDEX__(CSP_PROBLEM: CSP, ITERATION: int):
    """RETURNS A RANDOM INDEX.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    ITERATION : INTEGER
        THE ITERATION.

    RETURNS
    -------
    INDEX : INTEGER
        A RANDOM INDEX. IT CAN BE THE ITERATION OR A RANDOM INTEGER BETWEEN 0 AND THE MAXIMUM INDEX.
    """
    # MAX_INDEX, INTEGER, THE MAXIMUM INDEX.
    MAX_INDEX = len(CSP_PROBLEM.VARIABLES) - 1
    # IF THE ITERATION IS LESS THAN THE MAXIMUM INDEX, DO THE FOLLOWING:
    if ITERATION < MAX_INDEX:
        return ITERATION  # RETURN THE ITERATION.
    # RETURN A RANDOM INTEGER BETWEEN 0 AND THE MAXIMUM INDEX.
    return random.randint(0, MAX_INDEX)

# __SELECT_VALUE__(): [PRIVATE FUNCTION] RETURNS A RANDOM VALUE.


def __SELECT_VALUE__(CSP_PROBLEM: CSP, STATE: dict, VARIABLE: str):
    """RETURNS A RANDOM VALUE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    STATE : DICTIONARY
        THE STATE.
    VARIABLE : STRING
        THE VARIABLE.

    RETURNS
    -------
    VALUE : VALUE
        A RANDOM VALUE.
    """
    # VALUES, LIST, THE VALUES.
    VALUES = CSP_PROBLEM.DOMAINS[VARIABLE]
    # RANDOM_VALUE, VALUE, THE RANDOM VALUE.
    RANDOM_VALUE = random.choice(VALUES)
    # IF THE RANDOM VALUE IS NOT EQUAL TO THE STATE AT VARIABLE, RETURN THE RANDOM VALUE.
    if RANDOM_VALUE != STATE[VARIABLE]:
        return RANDOM_VALUE  # RETURN THE RANDOM VALUE.
    # RETURN THE RANDOM VALUE.
    return __SELECT_VALUE__(CSP_PROBLEM, STATE, VARIABLE)

# __COMPLETE__(): [PRIVATE FUNCTION] RETURNS TRUE IF THE ASSIGNMENT IS COMPLETE.


def __COMPLETE__(CSP_PROBLEM: CSP, STATE: dict):
    """RETURNS TRUE IF THE ASSIGNMENT IS COMPLETE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    STATE : DICTIONARY
        THE STATE.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE ASSIGNMENT IS COMPLETE. FALSE OTHERWISE.
    """
    # FOR EACH CONSTRAINT IN THE CONSTRAINTS, DO THE FOLLOWING:
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED, RETURN FALSE.
        if not __SATISFIED__(STATE, CONSTRAINT):
            return False  # RETURN FALSE.
    return True  # RETURN TRUE.

# __SATISFIED__(): [PRIVATE FUNCTION] RETURNS TRUE IF THE CONSTRAINT IS SATISFIED.


def __SATISFIED__(STATE: dict, CONSTRAINT: tuple):
    """RETURNS TRUE IF THE CONSTRAINT IS SATISFIED.

    PARAMETERS
    ----------
    STATE : DICTIONARY
        THE STATE.
    CONSTRAINT : TUPLE
        THE CONSTRAINT.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE CONSTRAINT IS SATISFIED. FALSE OTHERWISE.
    """
    # VARIABLE_1, VARIABLE, THE FIRST VARIABLE.
    VARIABLE_1 = CONSTRAINT[0]
    # VARIABLE_2, VARIABLE, THE SECOND VARIABLE.
    VARIABLE_2 = CONSTRAINT[1]
    # IF THE STATE AT VARIABLE 1 IS NOT EQUAL TO THE STATE AT VARIABLE 2, RETURN TRUE.
    if STATE[VARIABLE_1] != STATE[VARIABLE_2]:
        return True  # RETURN TRUE.
    return False  # RETURN FALSE.

# __BETTER__(): [PRIVATE FUNCTION] RETURNS TRUE IF THE CURRENT STATE IS BETTER THAN THE BEST STATE.


def __BETTER__(CSP_PROBLEM: CSP, CURRENT_STATE: dict, BEST_STATE: dict):
    """RETURNS TRUE IF THE CURRENT STATE IS BETTER THAN THE BEST STATE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    CURRENT_STATE : DICTIONARY
        THE CURRENT STATE.
    BEST_STATE : DICTIONARY
        THE BEST STATE.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE CURRENT STATE IS BETTER THAN THE BEST STATE. FALSE OTHERWISE.
    """
    # CURRENT_COST, INTEGER, THE CURRENT COST.
    CURRENT_COST = __CALCULATE_COST__(CSP_PROBLEM, CURRENT_STATE)
    # BEST_COST, INTEGER, THE BEST COST.
    BEST_COST = __CALCULATE_COST__(CSP_PROBLEM, BEST_STATE)
    # IF THE CURRENT COST IS LESS THAN THE BEST COST, RETURN TRUE.
    if CURRENT_COST < BEST_COST:
        return True  # RETURN TRUE.
    return False  # RETURN FALSE.

# __CALCULATE_COST__(): [PRIVATE FUNCTION] RETURNS THE COST OF THE STATE.


def __CALCULATE_COST__(CSP_PROBLEM: CSP, STATE: dict):
    """RETURNS THE COST OF THE STATE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.
    STATE : DICTIONARY
        THE STATE.

    RETURNS
    -------
    COST : INTEGER
        THE COST OF THE STATE. THE COST IS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED.
    """
    # COST, INTEGER, THE COST.
    COST = 0
    # FOR EACH CONSTRAINT IN THE CONSTRAINTS, DO THE FOLLOWING:
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED, INCREMENT THE COST.
        if not __SATISFIED__(STATE, CONSTRAINT):
            COST += 1  # INCREMENT THE COST.
    return COST  # RETURN THE COST.
