import random
from .CSP import CSP

# THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION REPRESENTS THE ENTRY POINT FOR SOLVING A CONSTRAINT SATISFACTION PROBLEM (CSP) USING THE LATE ACCEPTANCE HILL CLIMBING (LAHC) ALGORITHM. IT ENCAPSULATES THE ENTIRE PROCESS OF SOLVING THE PROBLEM AND RETURNS THE SOLUTION STATE.
# THE PURPOSE OF THE LATE_ACCEPTANCE_HILL_CLIMBING FUNCTION IS TO PROVIDE A CONVENIENT INTERFACE FOR USING THE LAHC ALGORITHM TO FIND A SOLUTION TO A GIVEN CSP PROBLEM. IT TAKES THE CSP PROBLEM INSTANCE, MAXIMUM NUMBER OF ITERATIONS, AND LAHC MEMORY LENGTH AS INPUT PARAMETERS.
#   1. IT INITIALIZES THE CURRENT STATE BY GENERATING A RANDOM STATE USING THE `__GENERATE_RANDOM_STATE__()` PRIVATE FUNCTION.
#   2. THE BEST STATE IS INITIALIZED AS THE CURRENT STATE.
#   3. THE LAHC LIST IS CREATED WITH THE BEST STATE AS THE INITIAL ELEMENT.
#   4. THE ALGORITHM PROCEEDS WITH A LOOP FOR THE MAXIMUM NUMBER OF ITERATIONS:
#       - IT RANDOMLY SELECTS A VARIABLE FROM THE CSP PROBLEM.
#       - IT RANDOMLY SELECTS A VALUE FOR THE SELECTED VARIABLE.
#       - THE SELECTED VALUE IS ASSIGNED TO THE SELECTED VARIABLE IN THE CURRENT STATE.
#       - IF THE ASSIGNMENT SATISFIES ALL THE CONSTRAINTS OF THE CSP, THE CURRENT STATE IS RETURNED AS THE SOLUTION.
#       - IF THE CURRENT STATE IS BETTER THAN THE BEST STATE, IT BECOMES THE NEW BEST STATE.
#       - THE BEST STATE IS APPENDED TO THE LAHC LIST.
#       - IF THE CURRENT ITERATION IS GREATER THAN OR EQUAL TO THE LAHC MEMORY LENGTH, THE CURRENT STATE IS UPDATED BY RETRIEVING A STATE FROM THE LAHC LIST BASED ON THE ITERATION NUMBER.
#   5. ONCE THE LOOP COMPLETES, THE BEST STATE, WHICH REPRESENTS THE BEST SOLUTION FOUND DURING THE SEARCH, IS RETURNED AS THE FINAL SOLUTION.
# THE LATE_ACCEPTANCE_HILL_CLIMBING FUNCTION PROVIDES A HIGH-LEVEL ABSTRACTION OF THE LAHC ALGORITHM, MAKING IT EASIER TO USE AND INTEGRATE WITH OTHER CODE. IT HIDES THE INTERNAL DETAILS OF THE ALGORITHM AND EXPOSES A SIMPLE INTERFACE TO LATE_ACCEPTANCE_HILL_CLIMBING CSP PROBLEMS.
def LATE_ACCEPTANCE_HILL_CLIMBING(CSP_PROBLEM: CSP, MAX_ITERATIONS: int, LAHC_MEMORY_LENGTH: int = 100) -> dict:
    """THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION REPRESENTS THE ENTRY POINT FOR SOLVING A CONSTRAINT SATISFACTION PROBLEM (CSP) USING THE LATE ACCEPTANCE HILL CLIMBING (LAHC) ALGORITHM. IT ENCAPSULATES THE ENTIRE PROCESS OF SOLVING THE PROBLEM AND RETURNS THE SOLUTION STATE."""
    # INITIALIZE THE CURRENT STATE BY GENERATING A RANDOM STATE
    CURRENT_STATE = __GENERATE_RANDOM_STATE__(CSP_PROBLEM)
    BEST_STATE = CURRENT_STATE  # INITIALIZE THE BEST STATE AS THE CURRENT STATE
    # INITIALIZE THE LAHC LIST WITH THE BEST STATE AS THE INITIAL ELEMENT
    LAHC_LIST = [BEST_STATE]
    # LOOP FOR THE MAXIMUM NUMBER OF ITERATIONS
    for ITERATION in range(MAX_ITERATIONS):
        # RANDOMLY SELECT A VARIABLE FROM THE CSP PROBLEM
        RANDOM_INDEX = __GET_RANDOM_INDEX__(CSP_PROBLEM, ITERATION)
        # RANDOMLY SELECT A VALUE FOR THE SELECTED VARIABLE
        RANDOM_VARIABLE = CSP_PROBLEM.VARIABLES[RANDOM_INDEX]
        # ASSIGN THE SELECTED VALUE TO THE SELECTED VARIABLE IN THE CURRENT STATE
        RANDOM_VALUE = __SELECT_VALUE__(
            CSP_PROBLEM, CURRENT_STATE, RANDOM_VARIABLE)
        # ASSIGN THE SELECTED VALUE TO THE SELECTED VARIABLE IN THE CURRENT STATE
        CURRENT_STATE[RANDOM_VARIABLE] = RANDOM_VALUE
        # IF THE ASSIGNMENT SATISFIES ALL THE CONSTRAINTS OF THE CSP
        if __COMPLETE__(CSP_PROBLEM, CURRENT_STATE):
            return CURRENT_STATE  # RETURN THE CURRENT STATE AS THE SOLUTION
        # IF THE CURRENT STATE IS BETTER THAN THE BEST STATE
        if __BETTER__(CSP_PROBLEM, CURRENT_STATE, BEST_STATE):
            BEST_STATE = CURRENT_STATE  # THE CURRENT STATE BECOMES THE NEW BEST STATE
        # APPEND THE BEST STATE TO THE LAHC LIST
        LAHC_LIST.append(BEST_STATE)
        # IF THE CURRENT ITERATION IS GREATER THAN OR EQUAL TO THE LAHC MEMORY LENGTH
        if ITERATION >= LAHC_MEMORY_LENGTH:
            # UPDATE THE CURRENT STATE BY RETRIEVING A STATE FROM THE LAHC LIST BASED ON THE ITERATION NUMBER
            CURRENT_STATE = LAHC_LIST[ITERATION - LAHC_MEMORY_LENGTH]
    return BEST_STATE  # RETURN THE BEST STATE AS THE SOLUTION

# THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM STATE FOR THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT IS INVOKED BY THE LATE_ACCEPTANCE_HILL_CLIMBING() FUNCTION TO INITIALIZE THE CURRENT STATE.
# THE PURPOSE OF THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS TO CREATE A RANDOM ASSIGNMENT OF VALUES TO VARIABLES, CREATING A RANDOM STATE FOR THE CSP PROBLEM.
# 	1. IT CREATES AN EMPTY DICTIONARY TO REPRESENT THE STATE.
# 	2. FOR EACH VARIABLE IN THE CSP PROBLEM, IT DOES THE FOLLOWING:
# 	   - IT RETRIEVES THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS.
# 	   - IT RANDOMLY SELECTS A VALUE FROM THE POSSIBLE VALUES USING THE `RANDOM.CHOICE()` FUNCTION.
# 	   - IT ASSIGNS THE RANDOMLY SELECTED VALUE TO THE VARIABLE IN THE STATE DICTIONARY.
# 	3. ONCE ALL VARIABLES HAVE BEEN ASSIGNED RANDOM VALUES, THE FUNCTION RETURNS THE GENERATED RANDOM STATE AS A DICTIONARY.
# THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS CRUCIAL FOR INITIALIZING THE SEARCH PROCESS. IT PROVIDES AN INITIAL RANDOM STATE THAT SERVES AS A STARTING POINT FOR THE LAHC ALGORITHM. BY RANDOMLY ASSIGNING VALUES TO VARIABLES, IT ENABLES THE ALGORITHM TO BEGIN EXPLORING THE SEARCH SPACE FROM A RANDOMIZED STATE, INCREASING THE CHANCES OF FINDING A GOOD SOLUTION.
def __GENERATE_RANDOM_STATE__(CSP_PROBLEM: CSP) -> dict:
    """THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM STATE FOR THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT IS INVOKED BY THE LATE_ACCEPTANCE_HILL_CLIMBING() FUNCTION TO INITIALIZE THE CURRENT STATE."""
    STATE = {}  # CREATE AN EMPTY DICTIONARY TO REPRESENT THE STATE
    for VARIABLE in CSP_PROBLEM.VARIABLES:  # FOR EACH VARIABLE IN THE CSP PROBLEM
        # RETRIEVE THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS
        VALUES = CSP_PROBLEM.DOMAINS[VARIABLE]
        # RANDOMLY SELECT A VALUE FROM THE POSSIBLE VALUES
        RANDOM_VALUE = random.choice(VALUES)
        # ASSIGN THE RANDOMLY SELECTED VALUE TO THE VARIABLE IN THE STATE DICTIONARY
        STATE[VARIABLE] = RANDOM_VALUE
    return STATE  # RETURN THE GENERATED RANDOM STATE AS A DICTIONARY

# THE `__GET_RANDOM_INDEX__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM INDEX. IT IS INVOKED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO SELECT A RANDOM VARIABLE FROM THE CSP PROBLEM.
# THE PURPOSE OF THE `__GET_RANDOM_INDEX__()` FUNCTION IS TO RANDOMLY SELECT AN INDEX REPRESENTING A VARIABLE FROM THE CSP PROBLEM.
# 	1. IT TAKES THE CSP PROBLEM INSTANCE AND THE CURRENT ITERATION NUMBER AS INPUT PARAMETERS.
# 	2. IT CALCULATES THE MAXIMUM INDEX BY SUBTRACTING 1 FROM THE LENGTH OF THE VARIABLES LIST IN THE CSP PROBLEM.
# 	3. IF THE CURRENT ITERATION NUMBER IS LESS THAN THE MAXIMUM INDEX, THE FUNCTION RETURNS THE CURRENT ITERATION NUMBER AS THE RANDOM INDEX.
# 	4. IF THE CURRENT ITERATION NUMBER IS EQUAL TO OR GREATER THAN THE MAXIMUM INDEX, THE FUNCTION GENERATES A RANDOM INTEGER BETWEEN 0 AND THE MAXIMUM INDEX (INCLUSIVE) USING THE `RANDOM.RANDINT()` FUNCTION, AND RETURNS THE RANDOM INDEX.
# THE `__GET_RANDOM_INDEX__()` FUNCTION ENSURES THAT THE RANDOM INDEX SELECTED FOR VARIABLE SELECTION VARIES DURING THE SEARCH PROCESS. THIS RANDOMNESS HELPS TO AVOID ANY BIAS OR PREDICTABILITY IN THE VARIABLE SELECTION, CONTRIBUTING TO A MORE DIVERSE AND EXPLORATORY SEARCH.
def __GET_RANDOM_INDEX__(CSP_PROBLEM: CSP, ITERATION: int) -> int:
    """THE `__GET_RANDOM_INDEX__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM INDEX. IT IS INVOKED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO SELECT A RANDOM VARIABLE FROM THE CSP PROBLEM."""
    # CALCULATE THE MAXIMUM INDEX BY SUBTRACTING 1 FROM THE LENGTH OF THE VARIABLES LIST IN THE CSP PROBLEM
    MAX_INDEX = len(CSP_PROBLEM.VARIABLES) - 1
    if ITERATION < MAX_INDEX:  # IF THE CURRENT ITERATION NUMBER IS LESS THAN THE MAXIMUM INDEX
        return ITERATION  # RETURN THE CURRENT ITERATION NUMBER AS THE RANDOM INDEX
    # IF THE CURRENT ITERATION NUMBER IS EQUAL TO OR GREATER THAN THE MAXIMUM INDEX, GENERATE A RANDOM INTEGER BETWEEN 0 AND THE MAXIMUM INDEX (INCLUSIVE) USING THE `RANDOM.RANDINT()` FUNCTION, AND RETURN THE RANDOM INDEX
    return random.randint(0, MAX_INDEX)

# THE `__SELECT_VALUE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR SELECTING A RANDOM VALUE FOR A GIVEN VARIABLE IN THE CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION DURING THE VARIABLE ASSIGNMENT PROCESS.
# THE PURPOSE OF THE `__SELECT_VALUE__()` FUNCTION IS TO RANDOMLY CHOOSE A VALUE FROM THE DOMAIN OF A VARIABLE IN THE CSP PROBLEM, EXCLUDING THE CURRENT VALUE OF THAT VARIABLE IN THE CURRENT STATE.
# 	1. IT TAKES THE CSP PROBLEM INSTANCE, THE CURRENT STATE, AND THE VARIABLE AS INPUT PARAMETERS.
# 	2. IT RETRIEVES THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS.
# 	3. IT RANDOMLY SELECTS A VALUE FROM THE POSSIBLE VALUES USING THE `RANDOM.CHOICE()` FUNCTION.
# 	4. IT COMPARES THE RANDOMLY SELECTED VALUE WITH THE CURRENT VALUE OF THE VARIABLE IN THE CURRENT STATE.
# 	5. IF THE RANDOMLY SELECTED VALUE IS DIFFERENT FROM THE CURRENT VALUE, IT RETURNS THE RANDOMLY SELECTED VALUE.
# 	6. IF THE RANDOMLY SELECTED VALUE IS THE SAME AS THE CURRENT VALUE, THE FUNCTION RECURSIVELY CALLS ITSELF TO SELECT ANOTHER VALUE, REPEATING STEPS 3-5 UNTIL A DIFFERENT VALUE IS OBTAINED.
# 	7. ONCE A DIFFERENT VALUE IS SELECTED, THE FUNCTION RETURNS THAT VALUE.
# THE `__SELECT_VALUE__()` FUNCTION ENSURES THAT THE RANDOMLY SELECTED VALUE FOR A VARIABLE IS NOT EQUAL TO ITS CURRENT VALUE IN THE CURRENT STATE. THIS HELPS TO AVOID REDUNDANT ASSIGNMENTS AND ENCOURAGES EXPLORATION OF DIFFERENT ASSIGNMENTS FOR VARIABLES, POTENTIALLY LEADING TO BETTER SOLUTIONS.
def __SELECT_VALUE__(CSP_PROBLEM: CSP, STATE: dict, VARIABLE: str) -> str:
    """THE `__SELECT_VALUE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR SELECTING A RANDOM VALUE FOR A GIVEN VARIABLE IN THE CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION DURING THE VARIABLE ASSIGNMENT PROCESS."""
    # RETRIEVE THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS
    VALUES = CSP_PROBLEM.DOMAINS[VARIABLE]
    # RANDOMLY SELECT A VALUE FROM THE POSSIBLE VALUES
    RANDOM_VALUE = random.choice(VALUES)
    # IF THE RANDOMLY SELECTED VALUE IS DIFFERENT FROM THE CURRENT VALUE
    if RANDOM_VALUE != STATE[VARIABLE]:
        return RANDOM_VALUE  # RETURN THE RANDOMLY SELECTED VALUE
    # IF THE RANDOMLY SELECTED VALUE IS THE SAME AS THE CURRENT VALUE, RECURSIVELY CALL THE FUNCTION TO SELECT ANOTHER VALUE
    return __SELECT_VALUE__(CSP_PROBLEM, STATE, VARIABLE)

# THE `__COMPLETE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF THE ASSIGNMENT IN THE CURRENT STATE IS COMPLETE FOR THE GIVEN CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF A VALID SOLUTION HAS BEEN FOUND.
# THE PURPOSE OF THE `__COMPLETE__()` FUNCTION IS TO VERIFY IF ALL CONSTRAINTS OF THE CSP PROBLEM ARE SATISFIED BY THE CURRENT ASSIGNMENT IN THE STATE.
#   1. IT TAKES THE CSP PROBLEM INSTANCE AND THE CURRENT STATE AS INPUT PARAMETERS.
#   2. FOR EACH CONSTRAINT IN THE CONSTRAINTS LIST OF THE CSP PROBLEM, IT DOES THE FOLLOWING:
#       - IT CALLS THE `__SATISFIED__()` FUNCTION, PASSING THE CURRENT STATE AND THE CONSTRAINT.
#       - IF THE CONSTRAINT IS NOT SATISFIED (THE `__SATISFIED__()` FUNCTION RETURNS FALSE), IT IMMEDIATELY RETURNS FALSE INDICATING THAT THE ASSIGNMENT IS NOT COMPLETE.
#   3. IF THE FUNCTION HAS CHECKED ALL CONSTRAINTS AND NONE OF THEM ARE VIOLATED, IT MEANS THAT THE ASSIGNMENT IS COMPLETE AND SATISFIES ALL CONSTRAINTS.
#   4. IN THIS CASE, THE FUNCTION RETURNS TRUE INDICATING THAT THE ASSIGNMENT IS COMPLETE AND A VALID SOLUTION HAS BEEN FOUND.
# THE `__COMPLETE__()` FUNCTION PLAYS A CRITICAL ROLE IN THE SEARCH PROCESS. IT HELPS TO DETERMINE WHETHER THE CURRENT STATE REPRESENTS A VALID SOLUTION TO THE CSP PROBLEM. BY ENSURING THAT ALL CONSTRAINTS ARE SATISFIED, IT PROVIDES A MEANS TO CHECK THE INTEGRITY AND VALIDITY OF THE CURRENT ASSIGNMENT.
def __COMPLETE__(CSP_PROBLEM: CSP, STATE: dict) -> bool:
    """THE `__COMPLETE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF THE ASSIGNMENT IN THE CURRENT STATE IS COMPLETE FOR THE GIVEN CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF A VALID SOLUTION HAS BEEN FOUND."""
    # FOR EACH CONSTRAINT IN THE CONSTRAINTS LIST OF THE CSP PROBLEM
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED
        if not __SATISFIED__(STATE, CONSTRAINT):
            return False  # RETURN FALSE INDICATING THAT THE ASSIGNMENT IS NOT COMPLETE
    return True  # IF THE FUNCTION HAS CHECKED ALL CONSTRAINTS AND NONE OF THEM ARE VIOLATED, IT MEANS THAT THE ASSIGNMENT IS COMPLETE AND SATISFIES ALL CONSTRAINTS. IN THIS CASE, THE FUNCTION RETURNS TRUE INDICATING THAT THE ASSIGNMENT IS COMPLETE AND A VALID SOLUTION HAS BEEN FOUND.

# THE `__SATISFIED__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF A SPECIFIC CONSTRAINT IS SATISFIED BY THE CURRENT STATE. IT IS USED BY THE `__COMPLETE__()` FUNCTION TO EVALUATE EACH CONSTRAINT OF THE CSP PROBLEM.
# THE PURPOSE OF THE `__SATISFIED__()` FUNCTION IS TO VERIFY WHETHER A CONSTRAINT, DEFINED BY A TUPLE OF VARIABLES, IS SATISFIED BY THE CURRENT ASSIGNMENT IN THE STATE.
#   1. IT TAKES THE CURRENT STATE (A DICTIONARY) AND A CONSTRAINT (A TUPLE OF TWO VARIABLES) AS INPUT PARAMETERS.
#   2. IT EXTRACTS THE TWO VARIABLES, `VARIABLE_1` AND `VARIABLE_2`, FROM THE CONSTRAINT TUPLE.
#   3. IT COMPARES THE VALUES ASSIGNED TO `VARIABLE_1` AND `VARIABLE_2` IN THE CURRENT STATE.
#   4. IF THE VALUES ARE NOT EQUAL, THE CONSTRAINT IS SATISFIED, AND THE FUNCTION RETURNS TRUE.
#   5. IF THE VALUES ARE EQUAL, THE CONSTRAINT IS NOT SATISFIED, AND THE FUNCTION RETURNS FALSE.
# THE `__SATISFIED__()` FUNCTION PLAYS A CRUCIAL ROLE IN EVALUATING THE CONSISTENCY OF ASSIGNMENTS. BY COMPARING THE VALUES OF THE VARIABLES INVOLVED IN A CONSTRAINT, IT DETERMINES WHETHER THE CONSTRAINT IS SATISFIED. THIS HELPS TO ENSURE THAT THE CURRENT ASSIGNMENT COMPLIES WITH THE CONSTRAINTS DEFINED BY THE CSP PROBLEM, CONTRIBUTING TO THE VALIDITY OF THE SOLUTION.
def __SATISFIED__(STATE: dict, CONSTRAINT: tuple) -> bool:
    """THE `__SATISFIED__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF A SPECIFIC CONSTRAINT IS SATISFIED BY THE CURRENT STATE. IT IS USED BY THE `__COMPLETE__()` FUNCTION TO EVALUATE EACH CONSTRAINT OF THE CSP PROBLEM."""
    # EXTRACT THE FIRST VARIABLE FROM THE CONSTRAINT TUPLE
    VARIABLE_1 = CONSTRAINT[0]
    # EXTRACT THE SECOND VARIABLE FROM THE CONSTRAINT TUPLE
    VARIABLE_2 = CONSTRAINT[1]
    # IF THE VALUES ASSIGNED TO THE TWO VARIABLES ARE NOT EQUAL
    if STATE[VARIABLE_1] != STATE[VARIABLE_2]:
        return True  # RETURN TRUE INDICATING THAT THE CONSTRAINT IS SATISFIED
    return False  # IF THE VALUES ASSIGNED TO THE TWO VARIABLES ARE EQUAL, RETURN FALSE INDICATING THAT THE CONSTRAINT IS NOT SATISFIED

# THE `__BETTER__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR COMPARING THE QUALITY OF THE CURRENT STATE WITH THE BEST STATE FOUND SO FAR. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF THE CURRENT STATE REPRESENTS AN IMPROVEMENT OVER THE BEST STATE.
# THE PURPOSE OF THE `__BETTER__()` FUNCTION IS TO COMPARE THE COST OF THE CURRENT STATE AND THE BEST STATE TO DETERMINE IF THE CURRENT STATE IS BETTER (I.E., HAS A LOWER COST) THAN THE BEST STATE.
# 	1. IT TAKES THE CSP PROBLEM INSTANCE, THE CURRENT STATE, AND THE BEST STATE AS INPUT PARAMETERS.
# 	2. IT CALLS THE `__CALCULATE_COST__()` FUNCTION, PASSING THE CSP PROBLEM INSTANCE AND THE CURRENT STATE, TO OBTAIN THE COST OF THE CURRENT STATE.
# 	3. IT CALLS THE `__CALCULATE_COST__()` FUNCTION AGAIN, PASSING THE CSP PROBLEM INSTANCE AND THE BEST STATE, TO OBTAIN THE COST OF THE BEST STATE.
# 	4. IT COMPARES THE COSTS OF THE CURRENT STATE AND THE BEST STATE.
# 	5. IF THE COST OF THE CURRENT STATE IS LESS THAN THE COST OF THE BEST STATE, IT MEANS THE CURRENT STATE IS BETTER.
# 	6. IN THIS CASE, THE FUNCTION RETURNS TRUE TO INDICATE THAT THE CURRENT STATE IS BETTER THAN THE BEST STATE.
# 	7. OTHERWISE, IF THE COST OF THE CURRENT STATE IS GREATER THAN OR EQUAL TO THE COST OF THE BEST STATE, THE FUNCTION RETURNS FALSE.
# THE `__BETTER__()` FUNCTION PLAYS A KEY ROLE IN THE SEARCH PROCESS. BY COMPARING THE COSTS OF DIFFERENT STATES, IT ALLOWS THE ALGORITHM TO MAKE DECISIONS BASED ON THE IMPROVEMENT OF THE CURRENT STATE COMPARED TO THE BEST STATE FOUND SO FAR. THIS HELPS TO DRIVE THE SEARCH TOWARDS BETTER SOLUTIONS BY FAVORING STATES WITH LOWER COSTS.
def __BETTER__(CSP_PROBLEM: CSP, CURRENT_STATE: dict, BEST_STATE: dict) -> bool:
    """THE `__BETTER__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR COMPARING THE QUALITY OF THE CURRENT STATE WITH THE BEST STATE FOUND SO FAR. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF THE CURRENT STATE REPRESENTS AN IMPROVEMENT OVER THE BEST STATE."""
    # CALL THE `__CALCULATE_COST__()` FUNCTION, PASSING THE CSP PROBLEM INSTANCE AND THE CURRENT STATE, TO OBTAIN THE COST OF THE CURRENT STATE
    CURRENT_COST = __CALCULATE_COST__(CSP_PROBLEM, CURRENT_STATE)
    # CALL THE `__CALCULATE_COST__()` FUNCTION AGAIN, PASSING THE CSP PROBLEM INSTANCE AND THE BEST STATE, TO OBTAIN THE COST OF THE BEST STATE
    BEST_COST = __CALCULATE_COST__(CSP_PROBLEM, BEST_STATE)
    if CURRENT_COST < BEST_COST:  # IF THE COST OF THE CURRENT STATE IS LESS THAN THE COST OF THE BEST STATE
        return True  # RETURN TRUE TO INDICATE THAT THE CURRENT STATE IS BETTER THAN THE BEST STATE
    return False  # OTHERWISE, IF THE COST OF THE CURRENT STATE IS GREATER THAN OR EQUAL TO THE COST OF THE BEST STATE, RETURN FALSE

# THE `__CALCULATE_COST__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT CALCULATES THE COST OF A GIVEN STATE IN THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT COUNTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
# 	1. IT TAKES THE CSP PROBLEM INSTANCE AND THE STATE AS INPUT PARAMETERS.
# 	2. IT INITIALIZES A VARIABLE CALLED `COST` TO KEEP TRACK OF THE COST OF THE STATE. THE COST IS INITIALLY SET TO 0.
# 	3. IT LOOPS THROUGH EACH CONSTRAINT IN THE CONSTRAINTS OF THE CSP PROBLEM.
# 	4. FOR EACH CONSTRAINT, IT CHECKS IF THE CONSTRAINT IS NOT SATISFIED BY THE STATE. IT CALLS THE `__SATISFIED__()` FUNCTION, PASSING THE STATE AND THE CONSTRAINT, TO CHECK IF THE CONSTRAINT IS SATISFIED.
# 	5. IF THE CONSTRAINT IS NOT SATISFIED, IT INCREMENTS THE `COST` VARIABLE BY 1 TO INDICATE THAT ONE CONSTRAINT IS NOT SATISFIED BY THE STATE.
# 	6. AFTER LOOPING THROUGH ALL CONSTRAINTS, THE FUNCTION RETURNS THE FINAL VALUE OF THE `COST` VARIABLE, WHICH REPRESENTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
# THE `__CALCULATE_COST__()` FUNCTION IS USED TO QUANTIFY THE QUALITY OF A STATE BY COUNTING THE NUMBER OF CONSTRAINTS THAT ARE VIOLATED. A LOWER COST INDICATES A BETTER STATE, AS IT REPRESENTS FEWER CONSTRAINT VIOLATIONS. THE ALGORITHM USES THIS COST INFORMATION TO GUIDE THE SEARCH TOWARDS FINDING A SOLUTION THAT MINIMIZES CONSTRAINT VIOLATIONS.
def __CALCULATE_COST__(CSP_PROBLEM: CSP, STATE: dict) -> int:
    """THE `__CALCULATE_COST__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT CALCULATES THE COST OF A GIVEN STATE IN THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT COUNTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE."""
    COST = 0  # INITIALIZE A VARIABLE TO KEEP TRACK OF THE COST OF THE STATE
    # LOOP THROUGH EACH CONSTRAINT IN THE CONSTRAINTS OF THE CSP PROBLEM
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED BY THE STATE
        if not __SATISFIED__(STATE, CONSTRAINT):
            COST += 1  # INCREMENT THE COST BY 1 TO INDICATE THAT ONE CONSTRAINT IS NOT SATISFIED BY THE STATE
    return COST  # RETURN THE FINAL VALUE OF THE COST VARIABLE, WHICH REPRESENTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE
