import math
import numpy as np

from .CSP_PROBLEM import CSP

# SIMULATED_ANNEALING(): RUNS THE SIMULATED ANNEALING ALGORITHM IN ORDER TO FIND A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM. RETURNS THE CURRENT STATE IF A SOLUTION IS FOUND, OTHERWISE RETURNS FALSE.
def SIMULATED_ANNEALING(CSP: CSP):
    # INITIALIZE THE CURRENT STATE WITH A RANDOM ASSIGNMENT OF VALUES TO THE VARIABLES.
    CURRENT_STATE = {}
    for VARIABLE in CSP.VARIABLES:
        CURRENT_STATE[VARIABLE] = np.random.choice(CSP.DOMAINS[VARIABLE])
    # INITIALIZE THE TEMPERATURE.
    TEMPERATURE = 100
    # INITIALIZE THE COOLING RATE.
    COOLING_RATE = 0.99
    # WHILE THE TEMPERATURE IS GREATER THAN 1, ITERATE.
    while TEMPERATURE > 1:
        # INITIALIZE THE NEXT STATE WITH A RANDOM ASSIGNMENT OF VALUES TO THE VARIABLES.
        NEXT_STATE = {}
        for VARIABLE in CSP.VARIABLES:
            NEXT_STATE[VARIABLE] = np.random.choice(CSP.DOMAINS[VARIABLE])
        # IF THE NEXT STATE IS BETTER THAN THE CURRENT STATE, THEN THE NEXT STATE BECOMES THE CURRENT STATE.
        if __COST_FUNCTION__(CSP, NEXT_STATE) < __COST_FUNCTION__(CSP, CURRENT_STATE):
            CURRENT_STATE = NEXT_STATE
        # OTHERWISE, IF THE NEXT STATE IS NOT BETTER THAN THE CURRENT STATE, THEN THE NEXT STATE BECOMES THE CURRENT STATE WITH A PROBABILITY THAT DEPENDS ON THE TEMPERATURE.
        else:
            # CALCULATE THE PROBABILITY THAT THE NEXT STATE BECOMES THE CURRENT STATE.
            PROBABILITY = math.exp(- (__COST_FUNCTION__(CSP, NEXT_STATE) - __COST_FUNCTION__(CSP, CURRENT_STATE)) / TEMPERATURE)
            # IF THE PROBABILITY IS GREATER THAN A RANDOM NUMBER BETWEEN 0 AND 1, THEN THE NEXT STATE BECOMES THE CURRENT STATE.
            if PROBABILITY > np.random.uniform(0, 1):
                CURRENT_STATE = NEXT_STATE
        # COOL THE TEMPERATURE.
        TEMPERATURE *= COOLING_RATE
    # RETURN TRUE IF THE CURRENT STATE IS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM, OTHERWISE RETURN FALSE.
    return CURRENT_STATE

# __COST_FUNCTION__() [PRIVATE FUNCTION]: CALCULATES THE COST OF A STATE. THE COST OF A STATE IS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
def __COST_FUNCTION__(CSP: CSP, STATE):
    # INITIALIZE THE COST.
    COST = 0
    # FOR EACH CONSTRAINT, CHECK IF THE CONSTRAINT IS SATISFIED BY THE STATE.
    for CONSTRAINT in CSP.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED BY THE STATE, INCREASE THE COST BY 1.
        if not __CONSTRAINT_SATISFIED__(CONSTRAINT, STATE):
            COST += 1
    # RETURN THE COST.
    return COST

# __CONSTRAINT_SATISFIED__() [PRIVATE FUNCTION]: CHECKS IF A CONSTRAINT IS SATISFIED BY A STATE. THE CONSTRAINT IS SATISFIED IF THE PAIR OF VARIABLES IN THE CONSTRAINT HAVE DIFFERENT VALUES IN THE STATE.
def __CONSTRAINT_SATISFIED__(CONSTRAINT, STATE):
    # RETURN TRUE IF THE PAIR OF VARIABLES IN THE CONSTRAINT HAVE DIFFERENT VALUES IN THE STATE, OTHERWISE RETURN FALSE.
    return STATE[CONSTRAINT[0]] != STATE[CONSTRAINT[1]]