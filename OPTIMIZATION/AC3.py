from .CSP import CSP

# IMPLEMENTS THE AC-3 ALGORITHM. THE AC-3 ALGORITHM IS A CONSTRAINT SATISFACTION PROBLEM (CSP) ALGORITHM THAT REDUCES THE DOMAIN OF THE VARIABLES OF A CSP PROBLEM, BY REMOVING THE VALUES THAT DO NOT SATISFY THE CONSTRAINTS OF THE PROBLEM. RETURNS FALSE IF AN INCONSISTENCY IS FOUND, OTHERWISE RETURNS TRUE.
#   1. IT INITIALIZES AN EMPTY `QUEUE` TO STORE THE ARCS OF THE CSP PROBLEM. THE ARCS REPRESENT RELATIONSHIPS BETWEEN VARIABLES.
# 	2. IT ITERATES OVER EACH VARIABLE IN `CSP_PROBLEM.VARIABLES`.
# 	3. FOR EACH VARIABLE, IT ITERATES OVER ITS NEIGHBORS (`NEIGHBOR`) USING THE `CSP_PROBLEM.NEIGHBORS` DICTIONARY.
# 	4. IT ADDS EACH ARC `(VARIABLE, NEIGHBOR)` TO THE `QUEUE`.
# 	5. THE METHOD ENTERS A `WHILE` LOOP THAT CONTINUES AS LONG AS THE `QUEUE` IS NOT EMPTY.
# 	6. IN EACH ITERATION OF THE LOOP, IT POPS THE FIRST ARC `(X_I, X_J)` FROM THE `QUEUE` USING `QUEUE.POP(0)`.
# 	7. IT CALLS THE `__REVISE__` METHOD TO REVISE THE DOMAINS OF THE VARIABLE `X_I` BASED ON THE CONSTRAINTS WITH `X_J`.
# 	8. IF THE DOMAINS OF `X_I` ARE REVISED (I.E., THERE ARE CHANGES), IT CHECKS IF THE DOMAIN OF `X_I` BECOMES EMPTY.
# 	   - IF THE DOMAIN OF `X_I` IS EMPTY, IT MEANS THERE IS AN INCONSISTENCY, AND THE METHOD RETURNS `FALSE` TO INDICATE FAILURE IN FINDING A SOLUTION.
# 	9. IF THE DOMAIN OF `X_I` IS NOT EMPTY AFTER REVISION, IT PROCEEDS TO UPDATE THE `QUEUE` WITH NEW ARCS.
# 	   - IT ITERATES OVER THE NEIGHBORS OF `X_I` (`X_K`) USING `CSP_PROBLEM.NEIGHBORS[X_I]`.
# 	   - FOR EACH NEIGHBOR `X_K`, EXCEPT `X_J`, IT ADDS THE ARC `(X_K, X_I)` TO THE `QUEUE`.
# 	10. THE LOOP CONTINUES UNTIL THE `QUEUE` IS EMPTY OR AN INCONSISTENCY IS DETECTED.
# 	11. IF THE LOOP COMPLETES WITHOUT FINDING AN INCONSISTENCY, THE METHOD RETURNS `TRUE` TO INDICATE THAT A SOLUTION WAS FOUND.
# IN SUMMARY, THE `SOLVE` METHOD APPLIES THE AC-3 ALGORITHM TO ITERATIVELY REVISE VARIABLE DOMAINS BASED ON CONSTRAINTS AND PROPAGATES THESE CHANGES THROUGH THE `QUEUE` UNTIL NO MORE REVISIONS CAN BE MADE OR AN INCONSISTENCY IS DETECTED. IT RETURNS `TRUE` IF A SOLUTION IS FOUND AND `FALSE` OTHERWISE.
def AC3(CSP_PROBLEM: CSP) -> bool:
    """IMPLEMENTS THE AC-3 ALGORITHM. THE AC-3 ALGORITHM IS A CONSTRAINT SATISFACTION PROBLEM (CSP) ALGORITHM THAT REDUCES THE DOMAIN OF THE VARIABLES OF A CSP PROBLEM, BY REMOVING THE VALUES THAT DO NOT SATISFY THE CONSTRAINTS OF THE PROBLEM. RETURNS FALSE IF AN INCONSISTENCY IS FOUND, OTHERWISE RETURNS TRUE."""
    QUEUE = []  # QUEUE, QUEUE OF ARCS, INITIALLY ALL THE ARCS IN THE PROBLEM.
    # FOR EACH VARIABLE, FIND THE NEIGHBORS OF THE VARIABLE.
    for VARIABLE in CSP_PROBLEM.VARIABLES:
        # FOR EACH NEIGHBOR OF THE VARIABLE, ADD THE ARC (VARIABLE, NEIGHBOR) TO THE QUEUE.
        for NEIGHBOR in CSP_PROBLEM.NEIGHBORS[VARIABLE]:
            # ADD THE ARC (VARIABLE, NEIGHBOR) TO THE QUEUE.
            QUEUE.append((VARIABLE, NEIGHBOR))
    # WHILE THE QUEUE IS NOT EMPTY, POP THE FIRST ARC (X_I, X_J) FROM THE QUEUE.
    while len(QUEUE) > 0:
        # POP THE FIRST ARC (X_I, X_J) FROM THE QUEUE.
        (X_I, X_J) = QUEUE.pop(0)
        # IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, DO THE FOLLOWING:
        if __REVISE__(CSP_PROBLEM, X_I, X_J):
            # IF THE DOMAIN OF THE VARIABLE X_I IS EMPTY, RETURN FALSE.
            if len(CSP_PROBLEM.DOMAINS[X_I]) == 0:
                return False  # RETURN FALSE.
            # FOR EACH X_K IN NEIGHBOURS MINUS X_J, ADD THE (X_K, X_I) TO THE QUEUE.
            for X_K in CSP_PROBLEM.NEIGHBORS[X_I]:
                # IF X_K IS DIFERENT THAN X_J, ADD THE (X_K, X_I) TO THE QUEUE.
                if X_K != X_J:
                    # ADD THE (X_K, X_I) TO THE QUEUE.
                    QUEUE.append((X_K, X_I))
    return True  # RETURNS TRUE.

# REVISES THE DOMAINS OF THE VARIABLE X_I, GIVEN THE DOMAINS OF THE VARIABLE X_J. RETURNS TRUE IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, OTHERWISE RETURNS FALSE.
# 	1. IT INITIALIZES A BOOLEAN VARIABLE `REVISED` TO `FALSE`. THIS VARIABLE KEEPS TRACK OF WHETHER THE DOMAINS OF `X_I` ARE REVISED OR NOT.
# 	2. IT ITERATES OVER EACH VALUE `X` IN THE DOMAIN OF VARIABLE `X_I` USING `CSP_PROBLEM.DOMAINS[X_I]`.
# 	3. FOR EACH VALUE `X`, IT INITIALIZES A BOOLEAN VARIABLE `SATISFIED` TO `FALSE`. THIS VARIABLE INDICATES IF THE VALUE `X` SATISFIES THE CONSTRAINT BETWEEN `X_I` AND `X_J`.
# 	4. IT ITERATES OVER EACH VALUE `Y` IN THE DOMAIN OF VARIABLE `X_J` USING `CSP_PROBLEM.DOMAINS[X_J]`.
# 	5. FOR EACH VALUE `Y`, IT CHECKS IF THE VALUE `X` IS DIFFERENT FROM `Y`. IF THEY ARE DIFFERENT, IT MEANS THE CONSTRAINT `(X_I, X_J)` IS SATISFIED.
# 	   - IF THE CONSTRAINT IS SATISFIED, IT SETS `SATISFIED` TO `TRUE`.
# 	   - IT BREAKS THE LOOP SINCE THERE IS NO NEED TO CHECK FURTHER VALUES OF `Y`.
# 	6. AFTER CHECKING ALL VALUES OF `Y`, IF `SATISFIED` IS STILL `FALSE`, IT MEANS NO VALUE `Y` IN THE DOMAIN OF `X_J` ALLOWS `(X, Y)` TO SATISFY THE CONSTRAINT BETWEEN `X_I` AND `X_J`.
# 	   - IN THIS CASE, IT REMOVES THE VALUE `X` FROM THE DOMAIN OF `X_I` BY USING `DEL CSP_PROBLEM.DOMAINS[X_I][CSP_PROBLEM.DOMAINS[X_I].INDEX(X)]`.
# 	   - IT SETS `REVISED` TO `TRUE` TO INDICATE THAT THE DOMAINS OF `X_I` ARE REVISED.
# 	7. AFTER ITERATING OVER ALL VALUES OF `X` IN THE DOMAIN OF `X_I`, IT RETURNS THE VALUE OF `REVISED`.
# IN SUMMARY, THE `__REVISE__` METHOD CHECKS IF EACH VALUE IN THE DOMAIN OF `X_I` SATISFIES THE CONSTRAINT WITH `X_J`. IF A VALUE DOES NOT SATISFY THE CONSTRAINT, IT IS REMOVED FROM THE DOMAIN OF `X_I`. THE METHOD RETURNS `TRUE` IF ANY VALUE IS REMOVED AND `FALSE` OTHERWISE.
def __REVISE__(CSP_PROBLEM: CSP, X_I: str, X_J: str):
    """REVISES THE DOMAINS OF THE VARIABLE X_I, GIVEN THE DOMAINS OF THE VARIABLE X_J. RETURNS TRUE IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED, OTHERWISE RETURNS FALSE."""
    # REVISED, BOOLEAN, INDICATES IF THE DOMAINS OF THE VARIABLE X_I ARE REVISED.
    REVISED = False
    # FOR EACH VALUE X OF THE DOMAIN OF THE VARIABLE X_I, CHECK IF THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
    for X in CSP_PROBLEM.DOMAINS[X_I]:
        # SATISFIED, BOOLEAN, INDICATES IF THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
        SATISFIED = False
        # FOR EACH VALUE Y OF THE DOMAIN OF THE VARIABLE X_J, CHECK IF THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
        for Y in CSP_PROBLEM.DOMAINS[X_J]:
            # IF THE VALUE X DOES NOT SATISFY THE CONSTRAINT (X_I, X_J), REMOVE THE VALUE X FROM THE DOMAIN OF THE VARIABLE X_I.
            if X != Y:
                # THE VALUE X SATISFIES THE CONSTRAINT (X_I, X_J).
                SATISFIED = True
                break  # BREAK THE LOOP.
        # IF THERE'S NO VALUE Y OF THE DOMAIN OF THE VARIABLE X_J THAT ALLOWS (X, Y) TO SATISFY THE CONSTRAINT BETWEEN (X_I, X_J), REMOVE THE VALUE X FROM THE DOMAIN OF THE VARIABLE X_I.
        if not SATISFIED:
            # REMOVE THE VALUE X FROM THE DOMAIN OF THE VARIABLE X_I.
            del CSP_PROBLEM.DOMAINS[X_I][CSP_PROBLEM.DOMAINS[X_I].index(X)]
            REVISED = True  # THE DOMAINS OF THE VARIABLE X_I ARE REVISED.
    return REVISED  # RETURN THE BOOLEAN REVISED.
