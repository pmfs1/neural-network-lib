from .CSP import CSP

# HILL_CLIMBING(): RUNS THE HILL CLIMBING ALGORITHM IN ORDER TO FIND A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM. RETURNS THE CURRENT STATE IF A SOLUTION IS FOUND, OTHERWISE RETURNS FALSE.


def HILL_CLIMBING(CSP_PROBLEM: CSP):
    """RUNS THE HILL CLIMBING ALGORITHM IN ORDER TO FIND A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM. RETURNS THE CURRENT STATE IF A SOLUTION IS FOUND, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM TO BE SOLVED.

    RETURNS
    -------
    CURRENT_STATE : DICT
        THE CURRENT STATE OF THE CONSTRAINT SATISFACTION PROBLEM. IF A SOLUTION IS NOT FOUND, THEN FALSE IS RETURNED.
    """
    # INITIALIZE THE CURRENT STATE TO THE INITIAL STATE.
    CURRENT_STATE = __INITIAL_STATE__(CSP_PROBLEM)
    # LOOP UNTIL A SOLUTION IS FOUND.
    while True:
        # IF THE CURRENT STATE IS A SOLUTION, THEN RETURN THE CURRENT STATE.
        if __SOLUTION__(CURRENT_STATE, CSP_PROBLEM):
            return CURRENT_STATE
        # FIND THE BEST SUCCESSOR OF THE CURRENT STATE.
        SUCCESSOR = __BEST_SUCCESSOR__(CURRENT_STATE, CSP_PROBLEM)
        # IF THERE IS NO SUCCESSOR, THEN RETURN FALSE.
        if SUCCESSOR is False:
            return False  # THERE IS NO SUCCESSOR.
        # SET THE CURRENT STATE TO THE SUCCESSOR.
        CURRENT_STATE = SUCCESSOR

# __INITIAL_STATE__() [PRIVATE FUNCTION]: RETURNS THE INITIAL STATE OF THE CONSTRAINT SATISFACTION PROBLEM.


def __INITIAL_STATE__(CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS THE INITIAL STATE OF THE CONSTRAINT SATISFACTION PROBLEM.

    PARAMETERS
    ----------
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    INITIAL_STATE : DICT
        THE INITIAL STATE OF THE CONSTRAINT SATISFACTION PROBLEM. THE INITIAL STATE IS THE FIRST VALUE IN THE DOMAIN OF EACH VARIABLE.
    """
    # INITIALIZE THE INITIAL STATE.
    INITIAL_STATE = {}
    # FOR EACH VARIABLE, FIND THE INITIAL VALUE OF THE VARIABLE.
    for VARIABLE in CSP_PROBLEM.VARIABLES:
        # SET THE INITIAL VALUE OF THE VARIABLE TO THE FIRST VALUE IN THE DOMAIN OF THE VARIABLE.
        INITIAL_STATE[VARIABLE] = CSP_PROBLEM.DOMAINS[VARIABLE][0]
    # RETURN THE INITIAL STATE.
    return INITIAL_STATE

# __SOLUTION__() [PRIVATE FUNCTION]: RETURNS TRUE IF THE STATE IS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM, OTHERWISE RETURNS FALSE.


def __SOLUTION__(STATE, CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS TRUE IF THE STATE IS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    STATE : DICT
        THE STATE OF THE CONSTRAINT SATISFACTION PROBLEM. THE STATE IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE STATE IS A SOLUTION TO THE CONSTRAINT SATISFACTION PROBLEM, OTHERWISE FALSE.
    """
    # FOR EACH CONSTRAINT, CHECK IF THE CONSTRAINT IS SATISFIED.
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED, THEN RETURN FALSE.
        if not __CONSTRAINT_SATISFIED__(STATE, CONSTRAINT):
            return False  # THE CONSTRAINT IS NOT SATISFIED.
    # RETURN TRUE.
    return True

# __CONSTRAINT_SATISFIED__() [PRIVATE FUNCTION]: RETURNS TRUE IF THE CONSTRAINT IS SATISFIED, OTHERWISE RETURNS FALSE.


def __CONSTRAINT_SATISFIED__(STATE, CONSTRAINT):
    """[PRIVATE FUNCTION] RETURNS TRUE IF THE CONSTRAINT IS SATISFIED, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    STATE : DICT
        THE STATE OF THE CONSTRAINT SATISFACTION PROBLEM. THE STATE IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CONSTRAINT : LIST
        THE CONSTRAINT. THE CONSTRAINT IS A LIST OF PAIRS OF VARIABLES.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE CONSTRAINT IS SATISFIED, OTHERWISE FALSE.
    """
    # FOR EACH VARIABLE INVOLVED IN THE CONSTRAINT, CHECK IF THE PAIR OF VARIABLES HAVE THE SAME VALUE.
    for VARIABLE_1, VARIABLE_2 in CONSTRAINT:
        # IF THE PAIR OF VARIABLES HAVE THE SAME VALUE, THEN RETURN FALSE.
        if STATE[VARIABLE_1] == STATE[VARIABLE_2]:
            return False  # THE CONSTRAINT IS NOT SATISFIED.
    # RETURN TRUE.
    return True

# __BEST_SUCCESSOR__() [PRIVATE FUNCTION]: RETURNS THE BEST SUCCESSOR OF THE STATE.


def __BEST_SUCCESSOR__(STATE, CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS THE BEST SUCCESSOR OF THE STATE.

    PARAMETERS
    ----------
    STATE : DICT
        THE STATE OF THE CONSTRAINT SATISFACTION PROBLEM. THE STATE IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    BEST_SUCCESSOR : DICT
        THE BEST SUCCESSOR OF THE STATE. IF THERE IS NO SUCCESSOR, THEN FALSE IS RETURNED. THE SUCCESSOR IS THE STATE WITH ONE VARIABLE CHANGED TO A VALUE IN THE DOMAIN OF THE VARIABLE.
    """
    # INITIALIZE THE BEST SUCCESSOR.
    BEST_SUCCESSOR = False
    # FOR EACH SUCCESSOR OF THE STATE, FIND THE BEST SUCCESSOR.
    for SUCCESSOR in __SUCCESSORS__(STATE, CSP_PROBLEM):
        # IF THE SUCCESSOR IS BETTER THAN THE BEST SUCCESSOR, THEN SET THE SUCCESSOR TO THE BEST SUCCESSOR.
        if __BETTER__(SUCCESSOR, BEST_SUCCESSOR, CSP_PROBLEM):
            BEST_SUCCESSOR = SUCCESSOR
    # RETURN THE BEST SUCCESSOR.
    return BEST_SUCCESSOR

# __SUCCESSORS__() [PRIVATE FUNCTION]: RETURNS THE SUCCESSORS OF THE STATE.


def __SUCCESSORS__(STATE, CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS THE SUCCESSORS OF THE STATE.

    PARAMETERS
    ----------
    STATE : DICT
        THE STATE OF THE CONSTRAINT SATISFACTION PROBLEM. THE STATE IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    SUCCESSORS : LIST
        THE SUCCESSORS OF THE STATE. THE SUCCESSORS ARE THE STATES WITH ONE VARIABLE CHANGED TO A VALUE IN THE DOMAIN OF THE VARIABLE.
    """
    # INITIALIZE THE SUCCESSORS.
    SUCCESSORS = []
    # FOR EACH VARIABLE, FIND THE SUCCESSORS OF THE STATE.
    for VARIABLE in CSP_PROBLEM.VARIABLES:
        # FOR EACH VALUE IN THE DOMAIN OF THE VARIABLE, FIND THE SUCCESSOR OF THE STATE.
        for VALUE in CSP_PROBLEM.DOMAINS[VARIABLE]:
            # IF THE VALUE IS NOT THE CURRENT VALUE OF THE VARIABLE, THEN FIND THE SUCCESSOR OF THE STATE.
            if VALUE != STATE[VARIABLE]:
                # INITIALIZE THE SUCCESSOR.
                SUCCESSOR = {}
                # FOR EACH VARIABLE, SET THE VALUE OF THE VARIABLE IN THE SUCCESSOR TO THE VALUE OF THE VARIABLE IN THE STATE.
                for VARIABLE_2 in CSP_PROBLEM.VARIABLES:
                    SUCCESSOR[VARIABLE_2] = STATE[VARIABLE_2]
                # SET THE VALUE OF THE VARIABLE IN THE SUCCESSOR TO THE VALUE.
                SUCCESSOR[VARIABLE] = VALUE
                # IF THE SUCCESSOR IS CONSISTENT, THEN ADD THE SUCCESSOR TO THE LIST OF SUCCESSORS.
                if __CONSISTENT__(SUCCESSOR, CSP_PROBLEM):
                    SUCCESSORS.append(SUCCESSOR)
    # RETURN THE SUCCESSORS.
    return SUCCESSORS

# __CONSISTENT__() [PRIVATE FUNCTION]: RETURNS TRUE IF THE SUCCESSOR IS CONSISTENT, OTHERWISE RETURNS FALSE.


def __CONSISTENT__(SUCCESSOR, CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS TRUE IF THE SUCCESSOR IS CONSISTENT, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    SUCCESSOR : DICT
        THE SUCCESSOR OF THE STATE. THE SUCCESSOR IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE SUCCESSOR IS CONSISTENT, OTHERWISE FALSE.
    """
    # FOR EACH CONSTRAINT, CHECK IF THE CONSTRAINT IS SATISFIED.
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED, THEN RETURN FALSE.
        if not __CONSTRAINT_SATISFIED__(SUCCESSOR, CONSTRAINT):
            return False  # THE CONSTRAINT IS NOT SATISFIED.
    # RETURN TRUE.
    return True

# __BETTER__() [PRIVATE FUNCTION]: RETURNS TRUE IF THE SUCCESSOR IS BETTER THAN THE BEST SUCCESSOR, OTHERWISE RETURNS FALSE.


def __BETTER__(SUCCESSOR, BEST_SUCCESSOR, CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS TRUE IF THE SUCCESSOR IS BETTER THAN THE BEST SUCCESSOR, OTHERWISE RETURNS FALSE.

    PARAMETERS
    ----------
    SUCCESSOR : DICT
        THE SUCCESSOR OF THE STATE. THE SUCCESSOR IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    BEST_SUCCESSOR : DICT
        THE BEST SUCCESSOR OF THE STATE. THE BEST SUCCESSOR IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    BOOLEAN
        TRUE IF THE SUCCESSOR IS BETTER THAN THE BEST SUCCESSOR, OTHERWISE FALSE.
    """
    # IF THERE IS NO BEST SUCCESSOR, THEN RETURN TRUE.
    if BEST_SUCCESSOR is False:
        return True  # THERE IS NO BEST SUCCESSOR.
    # IF THE SUCCESSOR IS CONSISTENT, THEN RETURN TRUE.
    if __CONSISTENT__(SUCCESSOR, CSP_PROBLEM):
        return True  # THE SUCCESSOR IS CONSISTENT.
    # IF THE BEST SUCCESSOR IS NOT CONSISTENT, THEN RETURN FALSE.
    if not __CONSISTENT__(BEST_SUCCESSOR, CSP_PROBLEM):
        return False  # THE BEST SUCCESSOR IS NOT CONSISTENT.
    # IF THE NUMBER OF VIOLATIONS OF THE SUCCESSOR IS LESS THAN THE NUMBER OF VIOLATIONS OF THE BEST SUCCESSOR, THEN RETURN TRUE.
    if __NUMBER_OF_VIOLATIONS__(SUCCESSOR, CSP_PROBLEM) < __NUMBER_OF_VIOLATIONS__(BEST_SUCCESSOR, CSP_PROBLEM):
        # THE NUMBER OF VIOLATIONS OF THE SUCCESSOR IS LESS THAN THE NUMBER OF VIOLATIONS OF THE BEST SUCCESSOR.
        return True
    # RETURN FALSE.
    return False

# __NUMBER_OF_VIOLATIONS__() [PRIVATE FUNCTION]: RETURNS THE NUMBER OF VIOLATIONS OF THE STATE.


def __NUMBER_OF_VIOLATIONS__(STATE, CSP_PROBLEM: CSP):
    """[PRIVATE FUNCTION] RETURNS THE NUMBER OF VIOLATIONS OF THE STATE.

    PARAMETERS
    ----------
    STATE : DICT
        THE STATE OF THE CONSTRAINT SATISFACTION PROBLEM. THE STATE IS A DICTIONARY OF VARIABLES AND THEIR VALUES.
    CSP_PROBLEM : CSP
        THE CONSTRAINT SATISFACTION PROBLEM.

    RETURNS
    -------
    NUMBER_OF_VIOLATIONS : INT
        THE NUMBER OF VIOLATIONS OF THE STATE. THE NUMBER OF VIOLATIONS IS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED.
    """
    # INITIALIZE THE NUMBER OF VIOLATIONS.
    NUMBER_OF_VIOLATIONS = 0
    # FOR EACH CONSTRAINT, FIND THE NUMBER OF VIOLATIONS.
    for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
        # IF THE CONSTRAINT IS NOT SATISFIED, THEN INCREMENT THE NUMBER OF VIOLATIONS.
        if not __CONSTRAINT_SATISFIED__(STATE, CONSTRAINT):
            NUMBER_OF_VIOLATIONS += 1
    # RETURN THE NUMBER OF VIOLATIONS.
    return NUMBER_OF_VIOLATIONS
