import numpy as np

# HARMONIC_REGRESSION: IMPLEMENTATION OF HARMONIC REGRESSION. HARMONIC REGRESSION IS A METHOD OF FITTING A CURVE TO A SET OF DATA POINTS BY MEANS OF A SINUSOIDAL FUNCTION. THE GOAL IS TO FIND THE BEST-FITTING CURVE TO A GIVEN SET OF POINTS BY MINIMIZING THE SUM OF SQUARES OF THE DIFFERENCES BETWEEN THE DATA POINTS AND THE CURVE.
class HARMONIC_REGRESSION:
    # INITIALIZES THE HARMONIC REGRESSION MODEL.
    def __init__(self, N_HARMONICS=1, N_ITER=300):
        # N_HARMONICS: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF HARMONICS. THE DEFAULT VALUE IS 1. EACH HARMONIC IS A SINUSOIDAL FUNCTION WITH A FREQUENCY THAT IS AN INTEGER MULTIPLE OF THE FUNDAMENTAL FREQUENCY. THE FUNDAMENTAL FREQUENCY IS THE INVERSE OF THE PERIOD OF THE FUNCTION.
        self.N_HARMONICS = N_HARMONICS
        # N_ITER: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF ITERATIONS FOR THE OPTIMIZATION. THE DEFAULT VALUE IS 300.
        self.N_ITER = N_ITER
        # WEIGHTS: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
        self.WEIGHTS = None
        # BIAS: IT'S THE PARAMETER THAT CORRESPONDS TO THE BIAS OF THE HARMONIC REGRESSION MODEL.
        self.BIAS = 0

    # FIT(): IT'S THE FUNCTION THAT TRAINS THE HARMONIC REGRESSION MODEL.
    def FIT(self, X, Y):
        # X: IT'S THE MATRIX OF FEATURES.
        X = np.array(X)
        # Y: IT'S THE VECTOR OF TARGETS.
        Y = np.array(Y)
        # N_SAMPLES: IT'S THE NUMBER OF SAMPLES.
        N_SAMPLES = X.shape[0]
        # N_FEATURES: IT'S THE NUMBER OF FEATURES.
        N_FEATURES = X.shape[1]
        # N_HARMONICS: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF HARMONICS. THE DEFAULT VALUE IS 1. EACH HARMONIC IS A SINUSOIDAL FUNCTION WITH A FREQUENCY THAT IS AN INTEGER MULTIPLE OF THE FUNDAMENTAL FREQUENCY. THE FUNDAMENTAL FREQUENCY IS THE INVERSE OF THE PERIOD OF THE FUNCTION.
        N_HARMONICS = self.N_HARMONICS
        # N_ITER: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF ITERATIONS FOR THE OPTIMIZATION. THE DEFAULT VALUE IS 300.
        N_ITER = self.N_ITER
        # W: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
        W = np.random.randn(N_FEATURES * N_HARMONICS)
        # B: IT'S THE PARAMETER THAT CORRESPONDS TO THE BIAS OF THE HARMONIC REGRESSION MODEL.
        B = np.random.randn()
        # L: IT'S THE LEARNING RATE.
        L = 0.001
        # FOR EACH ITERATION...
        for _ in range(N_ITER):
            # Y_HAT: IT'S THE PREDICTED OUTPUT VALUE.
            Y_HAT = np.dot(X, W) + B
            # D_W: IT'S THE DERIVATIVE OF THE LOSS FUNCTION WITH RESPECT TO THE WEIGHTS.
            D_W = (2 / N_SAMPLES) * np.dot(X.T, Y_HAT - Y)
            # D_B: IT'S THE DERIVATIVE OF THE LOSS FUNCTION WITH RESPECT TO THE BIAS.
            D_B = (2 / N_SAMPLES) * np.sum(Y_HAT - Y)
            # W: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
            W = W - L * D_W
            # B: IT'S THE PARAMETER THAT CORRESPONDS TO THE BIAS OF THE HARMONIC REGRESSION MODEL.
            B = B - L * D_B
        # WEIGHTS: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
        self.WEIGHTS = W
        # BIAS: IT'S THE PARAMETER THAT CORRESPONDS TO THE BIAS OF THE HARMONIC REGRESSION MODEL.
        self.BIAS = B
    
    # PREDICT(): IT'S THE FUNCTION THAT USES THE HARMONIC REGRESSION MODEL TO MAKE PREDICTIONS.
    def PREDICT(self, X):
        # RETURNS THE PREDICTED OUTPUT VALUE.
        return np.dot(X, self.WEIGHTS) + self.BIAS