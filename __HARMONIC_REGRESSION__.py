import numpy as np

# HARMONIC_REGRESSION: IMPLEMENTATION OF HARMONIC REGRESSION. HARMONIC REGRESSION IS A METHOD OF FITTING A CURVE TO A SET OF DATA POINTS BY MEANS OF A SINUSOIDAL FUNCTION. THE GOAL IS TO FIND THE BEST-FITTING CURVE TO A GIVEN SET OF POINTS BY MINIMIZING THE SUM OF SQUARES OF THE DIFFERENCES BETWEEN THE DATA POINTS AND THE CURVE.
class HARMONIC_REGRESSION:
    # INITIALIZES THE HARMONIC REGRESSION MODEL.
    def __init__(self, N_HARMONICS=1, N_ITER=300):
        # N_HARMONICS: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF HARMONICS. THE DEFAULT VALUE IS 1. EACH HARMONIC IS A SINUSOIDAL FUNCTION WITH A FREQUENCY THAT IS AN INTEGER MULTIPLE OF THE FUNDAMENTAL FREQUENCY. THE FUNDAMENTAL FREQUENCY IS THE INVERSE OF THE PERIOD OF THE FUNCTION.
        self.N_HARMONICS = N_HARMONICS
        # N_ITER: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF ITERATIONS FOR THE OPTIMIZATION. THE DEFAULT VALUE IS 300.
        self.N_ITER = N_ITER
        # WEIGHTS: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
        self.WEIGHTS = None

    # FIT(): IT'S THE FUNCTION THAT TRAINS THE HARMONIC REGRESSION MODEL.
    def FIT(self, X, Y):
        # N: IT'S THE NUMBER OF DATA POINTS.
        N = len(X)
        # T: IT'S THE PERIOD OF THE FUNCTION.
        T = 2 * np.pi / N
        # W: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
        W = np.random.randn(self.N_HARMONICS)
        # B: IT'S THE PARAMETER THAT CORRESPONDS TO THE BIAS OF THE HARMONIC REGRESSION MODEL.
        B = np.random.randn()
        # LOOP OVER THE NUMBER OF ITERATIONS.
        for _ in range(self.N_ITER):
            # LOOP OVER THE NUMBER OF HARMONICS.
            for i in range(self.N_HARMONICS):
                # LOOP OVER THE NUMBER OF DATA POINTS.
                for j in range(N):
                    # PREDICT THE OUTPUT VALUE.
                    Y_PRED = B + \
                        np.sum([W[k] * np.sin((k + 1) * (j + 1) * T)
                               for k in range(i + 1)])
                    # COMPUTE THE GRADIENT OF THE BIAS.
                    B_GRAD = -2 * (Y[j] - Y_PRED)
                    # COMPUTE THE GRADIENT OF THE WEIGHTS.
                    W_GRAD = -2 * (Y[j] - Y_PRED) * \
                        np.sin((i + 1) * (j + 1) * T)
                    # UPDATE THE BIAS.
                    B = B - 0.01 * B_GRAD
                    # UPDATE THE WEIGHTS.
                    W[i] = W[i] - 0.01 * W_GRAD
        # WEIGHTS: IT'S THE PARAMETER THAT CORRESPONDS TO THE WEIGHTS OF THE HARMONIC REGRESSION MODEL.
        self.WEIGHTS = W

    # TRANSFORM(): IT'S THE FUNCTION THAT USES THE HARMONIC REGRESSION MODEL TO PREDICT NEW OUTPUT VALUES.
    def TRANSFORM(self, X):
        # Y_PRED: IT'S THE PREDICTED OUTPUT VALUE.
        Y_PRED = []
        # N: IT'S THE NUMBER OF DATA POINTS.
        N = len(X)
        # T: IT'S THE PERIOD OF THE FUNCTION.
        T = 2 * np.pi / N
        # LOOP OVER THE NUMBER OF DATA POINTS.
        for i in range(N):
            # Y_PRED: IT'S THE PREDICTED OUTPUT VALUE.
            Y_PRED.append(np.sum(
                [self.WEIGHTS[k] * np.sin((k + 1) * (i + 1) * T) for k in range(self.N_HARMONICS)]))
        # RETURN THE PREDICTED OUTPUT VALUES.
        return Y_PRED