import numpy as np
from .CSP import CSP

# THE `LATE_ACCEPTANCE_HILL_CLIMBING` FUNCTION IS AN IMPLEMENTATION OF THE LATE ACCEPTANCE HILL CLIMBING ALGORITHM FOR SOLVING CONSTRAINT SATISFACTION PROBLEMS (CSPS).
#     1. THE FUNCTION TAKES THREE PARAMETERS: `CSP_PROBLEM`, WHICH REPRESENTS THE CSP TO BE SOLVED AND IS AN INSTANCE OF THE `CSP` CLASS, `MAX_ITERATIONS`, WHICH SPECIFIES THE MAXIMUM NUMBER OF ITERATIONS TO PERFORM, AND `LAHC_MEMORY_LENGTH` (OPTIONAL) WHICH DETERMINES THE LENGTH OF THE MEMORY USED BY THE LATE ACCEPTANCE HILL CLIMBING ALGORITHM.
#     2. THE FUNCTION DEFINES SEVERAL HELPER FUNCTIONS THAT ARE USED INTERNALLY:
#         - `__GENERATE_RANDOM_STATE__`: THIS FUNCTION GENERATES A RANDOM INITIAL STATE FOR THE CSP PROBLEM BY RANDOMLY ASSIGNING VALUES TO VARIABLES.
#         - `__GET_RANDOM_INDEX__`: THIS FUNCTION GENERATES A RANDOM INDEX TO SELECT A VARIABLE FROM THE CSP PROBLEM. THE INDEX IS USED TO SELECT A RANDOM VARIABLE DURING THE HILL CLIMBING PROCESS.
#         - `__SELECT_VALUE__`: THIS FUNCTION SELECTS A RANDOM VALUE FOR A GIVEN VARIABLE IN THE CSP PROBLEM. IT IS USED DURING THE VARIABLE ASSIGNMENT PROCESS IN THE HILL CLIMBING ALGORITHM.
#         - `__COMPLETE__`: THIS FUNCTION CHECKS IF THE ASSIGNMENT IN THE CURRENT STATE IS COMPLETE FOR THE GIVEN CSP PROBLEM. IT IS USED TO DETERMINE IF A VALID SOLUTION HAS BEEN FOUND.
#         - `__SATISFIED__`: THIS FUNCTION CHECKS IF A SPECIFIC CONSTRAINT IS SATISFIED BY THE CURRENT STATE. IT EVALUATES EACH CONSTRAINT OF THE CSP PROBLEM.
#         - `__BETTER__`: THIS FUNCTION COMPARES THE QUALITY OF THE CURRENT STATE WITH THE BEST STATE FOUND SO FAR. IT IS USED TO DETERMINE IF THE CURRENT STATE REPRESENTS AN IMPROVEMENT OVER THE BEST STATE.
#         - `__CALCULATE_COST__`: THIS FUNCTION CALCULATES THE COST OF A GIVEN STATE IN THE CSP PROBLEM. IT COUNTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
#     3. THE FUNCTION INITIALIZES THE CURRENT STATE AND THE BEST STATE TO A RANDOMLY GENERATED STATE USING THE `__GENERATE_RANDOM_STATE__` FUNCTION. THE BEST STATE REPRESENTS THE BEST SOLUTION FOUND SO FAR.
#     4. THE FUNCTION CREATES AN EMPTY LIST `LAHC_LIST` TO STORE THE BEST STATES ENCOUNTERED DURING THE HILL CLIMBING PROCESS.
#     5. THE FUNCTION ENTERS A LOOP THAT ITERATES `MAX_ITERATIONS` TIMES.
#     6. IN EACH ITERATION, A RANDOM INDEX IS GENERATED USING THE `__GET_RANDOM_INDEX__` FUNCTION. THIS INDEX IS USED TO SELECT A RANDOM VARIABLE FROM THE CSP PROBLEM.
#     7. THE SELECTED VARIABLE IS ASSIGNED A RANDOM VALUE USING THE `__SELECT_VALUE__` FUNCTION.
#     8. IF THE ASSIGNMENT IN THE CURRENT STATE IS COMPLETE (I.E., ALL VARIABLES HAVE BEEN ASSIGNED VALUES THAT SATISFY THE CONSTRAINTS), THE CURRENT STATE IS RETURNED AS THE SOLUTION.
#     9. IF THE CURRENT STATE IS BETTER THAN THE BEST STATE FOUND SO FAR (DETERMINED BY THE `__BETTER__` FUNCTION), THE CURRENT STATE BECOMES THE NEW BEST STATE.
#     10. THE BEST STATE IS ADDED TO THE `LAHC_LIST`.
#     11. IF THE NUMBER OF ITERATIONS IS GREATER THAN OR EQUAL TO `LAHC_MEMORY_LENGTH`, THE CURRENT STATE IS UPDATED TO THE STATE `LAHC_MEMORY_LENGTH` ITERATIONS AGO. THIS IS DONE TO IMPLEMENT THE LATE ACCEPTANCE MECHANISM, WHERE THE ALGORITHM ACCEPTS WORSE SOLUTIONS EARLY IN THE PROCESS BUT BECOMES MORE SELECTIVE OVER TIME.
#     12. AFTER THE LOOP ENDS, THE BEST STATE FOUND IS RETURNED AS THE SOLUTION TO THE CSP PROBLEM.
# OVERALL, THE LATE ACCEPTANCE HILL CLIMBING ALGORITHM AIMS TO FIND A VALID SOLUTION TO A CSP PROBLEM BY ITERATIVELY ASSIGNING RANDOM VALUES TO VARIABLES AND ACCEPTING WORSE SOLUTIONS EARLY IN THE PROCESS. IT MAINTAINS A MEMORY OF THE BEST STATES ENCOUNTERED AND BECOMES MORE SELECTIVE OVER TIME TO CONVERGE TOWARDS AN OPTIMAL OR NEAR-OPTIMAL SOLUTION.
def LATE_ACCEPTANCE_HILL_CLIMBING(CSP_PROBLEM: CSP, MAX_ITERATIONS: int, LAHC_MEMORY_LENGTH: int = 100) -> dict:
    """THE `LATE_ACCEPTANCE_HILL_CLIMBING` FUNCTION IS AN IMPLEMENTATION OF THE LATE ACCEPTANCE HILL CLIMBING ALGORITHM FOR SOLVING CONSTRAINT SATISFACTION PROBLEMS (CSPS)."""
    
    # THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM STATE FOR THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT IS INVOKED BY THE LATE_ACCEPTANCE_HILL_CLIMBING() FUNCTION TO INITIALIZE THE CURRENT STATE.
    # THE PURPOSE OF THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS TO CREATE A RANDOM ASSIGNMENT OF VALUES TO VARIABLES, CREATING A RANDOM STATE FOR THE CSP PROBLEM.
    # 	1. IT CREATES AN EMPTY DICTIONARY TO REPRESENT THE STATE.
    # 	2. FOR EACH VARIABLE IN THE CSP PROBLEM, IT DOES THE FOLLOWING:
    # 	   - IT RETRIEVES THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS.
    # 	   - IT RANDOMLY SELECTS A VALUE FROM THE POSSIBLE VALUES USING THE `RANDOM.CHOICE()` FUNCTION.
    # 	   - IT ASSIGNS THE RANDOMLY SELECTED VALUE TO THE VARIABLE IN THE STATE DICTIONARY.
    # 	3. ONCE ALL VARIABLES HAVE BEEN ASSIGNED RANDOM VALUES, THE FUNCTION RETURNS THE GENERATED RANDOM STATE AS A DICTIONARY.
    # THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS CRUCIAL FOR INITIALIZING THE SEARCH PROCESS. IT PROVIDES AN INITIAL RANDOM STATE THAT SERVES AS A STARTING POINT FOR THE LAHC ALGORITHM. BY RANDOMLY ASSIGNING VALUES TO VARIABLES, IT ENABLES THE ALGORITHM TO BEGIN EXPLORING THE SEARCH SPACE FROM A RANDOMIZED STATE, INCREASING THE CHANCES OF FINDING A GOOD SOLUTION.
    def __GENERATE_RANDOM_STATE__() -> dict:
        """THE `__GENERATE_RANDOM_STATE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM STATE FOR THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT IS INVOKED BY THE LATE_ACCEPTANCE_HILL_CLIMBING() FUNCTION TO INITIALIZE THE CURRENT STATE."""
        STATE = {}  # CREATE AN EMPTY DICTIONARY TO REPRESENT THE STATE
        for VARIABLE in CSP_PROBLEM.VARIABLES:  # FOR EACH VARIABLE IN THE CSP PROBLEM
            # RETRIEVE THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS
            VALUES = CSP_PROBLEM.DOMAINS[VARIABLE]
            # RANDOMLY SELECT A VALUE FROM THE POSSIBLE VALUES
            RANDOM_VALUE = np.random.choice(VALUES)
            # ASSIGN THE RANDOMLY SELECTED VALUE TO THE VARIABLE IN THE STATE DICTIONARY
            STATE[VARIABLE] = RANDOM_VALUE
        return STATE  # RETURN THE GENERATED RANDOM STATE AS A DICTIONARY

    # THE `__GET_RANDOM_INDEX__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM INDEX. IT IS INVOKED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO SELECT A RANDOM VARIABLE FROM THE CSP PROBLEM.
    # THE PURPOSE OF THE `__GET_RANDOM_INDEX__()` FUNCTION IS TO RANDOMLY SELECT AN INDEX REPRESENTING A VARIABLE FROM THE CSP PROBLEM.
    # 	1. IT TAKES THE CSP PROBLEM INSTANCE AND THE CURRENT ITERATION NUMBER AS INPUT PARAMETERS.
    # 	2. IT CALCULATES THE MAXIMUM INDEX BY SUBTRACTING 1 FROM THE LENGTH OF THE VARIABLES LIST IN THE CSP PROBLEM.
    # 	3. IF THE CURRENT ITERATION NUMBER IS LESS THAN THE MAXIMUM INDEX, THE FUNCTION RETURNS THE CURRENT ITERATION NUMBER AS THE RANDOM INDEX.
    # 	4. IF THE CURRENT ITERATION NUMBER IS EQUAL TO OR GREATER THAN THE MAXIMUM INDEX, THE FUNCTION GENERATES A RANDOM INTEGER BETWEEN 0 AND THE MAXIMUM INDEX (INCLUSIVE) USING THE `RANDOM.RANDINT()` FUNCTION, AND RETURNS THE RANDOM INDEX.
    # THE `__GET_RANDOM_INDEX__()` FUNCTION ENSURES THAT THE RANDOM INDEX SELECTED FOR VARIABLE SELECTION VARIES DURING THE SEARCH PROCESS. THIS RANDOMNESS HELPS TO AVOID ANY BIAS OR PREDICTABILITY IN THE VARIABLE SELECTION, CONTRIBUTING TO A MORE DIVERSE AND EXPLORATORY SEARCH.
    def __GET_RANDOM_INDEX__(ITERATION: int) -> int:
        """THE `__GET_RANDOM_INDEX__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR GENERATING A RANDOM INDEX. IT IS INVOKED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO SELECT A RANDOM VARIABLE FROM THE CSP PROBLEM."""
        # CALCULATE THE MAXIMUM INDEX BY SUBTRACTING 1 FROM THE LENGTH OF THE VARIABLES LIST IN THE CSP PROBLEM
        MAX_INDEX = len(CSP_PROBLEM.VARIABLES) - 1
        if ITERATION < MAX_INDEX:  # IF THE CURRENT ITERATION NUMBER IS LESS THAN THE MAXIMUM INDEX
            return ITERATION  # RETURN THE CURRENT ITERATION NUMBER AS THE RANDOM INDEX
        # IF THE CURRENT ITERATION NUMBER IS EQUAL TO OR GREATER THAN THE MAXIMUM INDEX, GENERATE A RANDOM INTEGER BETWEEN 0 AND THE MAXIMUM INDEX (INCLUSIVE) USING THE `RANDOM.RANDINT()` FUNCTION, AND RETURN THE RANDOM INDEX
        return np.random.randint(0, MAX_INDEX)

    # THE `__SELECT_VALUE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR SELECTING A RANDOM VALUE FOR A GIVEN VARIABLE IN THE CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION DURING THE VARIABLE ASSIGNMENT PROCESS.
    # THE PURPOSE OF THE `__SELECT_VALUE__()` FUNCTION IS TO RANDOMLY CHOOSE A VALUE FROM THE DOMAIN OF A VARIABLE IN THE CSP PROBLEM, EXCLUDING THE CURRENT VALUE OF THAT VARIABLE IN THE CURRENT STATE.
    # 	1. IT TAKES THE CSP PROBLEM INSTANCE, THE CURRENT STATE, AND THE VARIABLE AS INPUT PARAMETERS.
    # 	2. IT RETRIEVES THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS.
    # 	3. IT RANDOMLY SELECTS A VALUE FROM THE POSSIBLE VALUES USING THE `RANDOM.CHOICE()` FUNCTION.
    # 	4. IT COMPARES THE RANDOMLY SELECTED VALUE WITH THE CURRENT VALUE OF THE VARIABLE IN THE CURRENT STATE.
    # 	5. IF THE RANDOMLY SELECTED VALUE IS DIFFERENT FROM THE CURRENT VALUE, IT RETURNS THE RANDOMLY SELECTED VALUE.
    # 	6. IF THE RANDOMLY SELECTED VALUE IS THE SAME AS THE CURRENT VALUE, THE FUNCTION RECURSIVELY CALLS ITSELF TO SELECT ANOTHER VALUE, REPEATING STEPS 3-5 UNTIL A DIFFERENT VALUE IS OBTAINED.
    # 	7. ONCE A DIFFERENT VALUE IS SELECTED, THE FUNCTION RETURNS THAT VALUE.
    # THE `__SELECT_VALUE__()` FUNCTION ENSURES THAT THE RANDOMLY SELECTED VALUE FOR A VARIABLE IS NOT EQUAL TO ITS CURRENT VALUE IN THE CURRENT STATE. THIS HELPS TO AVOID REDUNDANT ASSIGNMENTS AND ENCOURAGES EXPLORATION OF DIFFERENT ASSIGNMENTS FOR VARIABLES, POTENTIALLY LEADING TO BETTER SOLUTIONS.
    def __SELECT_VALUE__(STATE: dict, VARIABLE: str) -> str:
        """THE `__SELECT_VALUE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR SELECTING A RANDOM VALUE FOR A GIVEN VARIABLE IN THE CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION DURING THE VARIABLE ASSIGNMENT PROCESS."""
        # RETRIEVE THE POSSIBLE VALUES FOR THE VARIABLE FROM THE CSP PROBLEM DOMAINS
        VALUES = CSP_PROBLEM.DOMAINS[VARIABLE]
        # RANDOMLY SELECT A VALUE FROM THE POSSIBLE VALUES
        RANDOM_VALUE = np.random.choice(VALUES)
        # IF THE RANDOMLY SELECTED VALUE IS DIFFERENT FROM THE CURRENT VALUE
        if RANDOM_VALUE != STATE[VARIABLE]:
            return RANDOM_VALUE  # RETURN THE RANDOMLY SELECTED VALUE
        # IF THE RANDOMLY SELECTED VALUE IS THE SAME AS THE CURRENT VALUE, RECURSIVELY CALL THE FUNCTION TO SELECT ANOTHER VALUE
        return __SELECT_VALUE__(STATE, VARIABLE)

    # THE `__COMPLETE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF THE ASSIGNMENT IN THE CURRENT STATE IS COMPLETE FOR THE GIVEN CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF A VALID SOLUTION HAS BEEN FOUND.
    # THE PURPOSE OF THE `__COMPLETE__()` FUNCTION IS TO VERIFY IF ALL CONSTRAINTS OF THE CSP PROBLEM ARE SATISFIED BY THE CURRENT ASSIGNMENT IN THE STATE.
    #   1. IT TAKES THE CSP PROBLEM INSTANCE AND THE CURRENT STATE AS INPUT PARAMETERS.
    #   2. FOR EACH CONSTRAINT IN THE CONSTRAINTS LIST OF THE CSP PROBLEM, IT DOES THE FOLLOWING:
    #       - IT CALLS THE `__SATISFIED__()` FUNCTION, PASSING THE CURRENT STATE AND THE CONSTRAINT.
    #       - IF THE CONSTRAINT IS NOT SATISFIED (THE `__SATISFIED__()` FUNCTION RETURNS FALSE), IT IMMEDIATELY RETURNS FALSE INDICATING THAT THE ASSIGNMENT IS NOT COMPLETE.
    #   3. IF THE FUNCTION HAS CHECKED ALL CONSTRAINTS AND NONE OF THEM ARE VIOLATED, IT MEANS THAT THE ASSIGNMENT IS COMPLETE AND SATISFIES ALL CONSTRAINTS.
    #   4. IN THIS CASE, THE FUNCTION RETURNS TRUE INDICATING THAT THE ASSIGNMENT IS COMPLETE AND A VALID SOLUTION HAS BEEN FOUND.
    # THE `__COMPLETE__()` FUNCTION PLAYS A CRITICAL ROLE IN THE SEARCH PROCESS. IT HELPS TO DETERMINE WHETHER THE CURRENT STATE REPRESENTS A VALID SOLUTION TO THE CSP PROBLEM. BY ENSURING THAT ALL CONSTRAINTS ARE SATISFIED, IT PROVIDES A MEANS TO CHECK THE INTEGRITY AND VALIDITY OF THE CURRENT ASSIGNMENT.
    def __COMPLETE__(STATE: dict) -> bool:
        """THE `__COMPLETE__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF THE ASSIGNMENT IN THE CURRENT STATE IS COMPLETE FOR THE GIVEN CSP PROBLEM. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF A VALID SOLUTION HAS BEEN FOUND."""
        # FOR EACH CONSTRAINT IN THE CONSTRAINTS LIST OF THE CSP PROBLEM
        for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
            # IF THE CONSTRAINT IS NOT SATISFIED
            if not __SATISFIED__(STATE, CONSTRAINT):
                return False  # RETURN FALSE INDICATING THAT THE ASSIGNMENT IS NOT COMPLETE
        return True  # IF THE FUNCTION HAS CHECKED ALL CONSTRAINTS AND NONE OF THEM ARE VIOLATED, IT MEANS THAT THE ASSIGNMENT IS COMPLETE AND SATISFIES ALL CONSTRAINTS. IN THIS CASE, THE FUNCTION RETURNS TRUE INDICATING THAT THE ASSIGNMENT IS COMPLETE AND A VALID SOLUTION HAS BEEN FOUND.

    # THE `__SATISFIED__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF A SPECIFIC CONSTRAINT IS SATISFIED BY THE CURRENT STATE. IT IS USED BY THE `__COMPLETE__()` FUNCTION TO EVALUATE EACH CONSTRAINT OF THE CSP PROBLEM.
    # THE PURPOSE OF THE `__SATISFIED__()` FUNCTION IS TO VERIFY WHETHER A CONSTRAINT, DEFINED BY A TUPLE OF VARIABLES, IS SATISFIED BY THE CURRENT ASSIGNMENT IN THE STATE.
    #   1. IT TAKES THE CURRENT STATE (A DICTIONARY) AND A CONSTRAINT (A TUPLE OF TWO VARIABLES) AS INPUT PARAMETERS.
    #   2. IT EXTRACTS THE TWO VARIABLES, `VARIABLE_1` AND `VARIABLE_2`, FROM THE CONSTRAINT TUPLE.
    #   3. IT COMPARES THE VALUES ASSIGNED TO `VARIABLE_1` AND `VARIABLE_2` IN THE CURRENT STATE.
    #   4. IF THE VALUES ARE NOT EQUAL, THE CONSTRAINT IS SATISFIED, AND THE FUNCTION RETURNS TRUE.
    #   5. IF THE VALUES ARE EQUAL, THE CONSTRAINT IS NOT SATISFIED, AND THE FUNCTION RETURNS FALSE.
    # THE `__SATISFIED__()` FUNCTION PLAYS A CRUCIAL ROLE IN EVALUATING THE CONSISTENCY OF ASSIGNMENTS. BY COMPARING THE VALUES OF THE VARIABLES INVOLVED IN A CONSTRAINT, IT DETERMINES WHETHER THE CONSTRAINT IS SATISFIED. THIS HELPS TO ENSURE THAT THE CURRENT ASSIGNMENT COMPLIES WITH THE CONSTRAINTS DEFINED BY THE CSP PROBLEM, CONTRIBUTING TO THE VALIDITY OF THE SOLUTION.
    def __SATISFIED__(STATE: dict, CONSTRAINT: tuple) -> bool:
        """THE `__SATISFIED__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR CHECKING IF A SPECIFIC CONSTRAINT IS SATISFIED BY THE CURRENT STATE. IT IS USED BY THE `__COMPLETE__()` FUNCTION TO EVALUATE EACH CONSTRAINT OF THE CSP PROBLEM."""
        # EXTRACT THE FIRST VARIABLE FROM THE CONSTRAINT TUPLE
        VARIABLE_1 = CONSTRAINT[0]
        # EXTRACT THE SECOND VARIABLE FROM THE CONSTRAINT TUPLE
        VARIABLE_2 = CONSTRAINT[1]
        # IF THE VALUES ASSIGNED TO THE TWO VARIABLES ARE NOT EQUAL
        if STATE[VARIABLE_1] != STATE[VARIABLE_2]:
            return True  # RETURN TRUE INDICATING THAT THE CONSTRAINT IS SATISFIED
        return False  # IF THE VALUES ASSIGNED TO THE TWO VARIABLES ARE EQUAL, RETURN FALSE INDICATING THAT THE CONSTRAINT IS NOT SATISFIED

    # THE `__BETTER__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR COMPARING THE QUALITY OF THE CURRENT STATE WITH THE BEST STATE FOUND SO FAR. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF THE CURRENT STATE REPRESENTS AN IMPROVEMENT OVER THE BEST STATE.
    # THE PURPOSE OF THE `__BETTER__()` FUNCTION IS TO COMPARE THE COST OF THE CURRENT STATE AND THE BEST STATE TO DETERMINE IF THE CURRENT STATE IS BETTER (I.E., HAS A LOWER COST) THAN THE BEST STATE.
    # 	1. IT TAKES THE CSP PROBLEM INSTANCE, THE CURRENT STATE, AND THE BEST STATE AS INPUT PARAMETERS.
    # 	2. IT CALLS THE `__CALCULATE_COST__()` FUNCTION, PASSING THE CSP PROBLEM INSTANCE AND THE CURRENT STATE, TO OBTAIN THE COST OF THE CURRENT STATE.
    # 	3. IT CALLS THE `__CALCULATE_COST__()` FUNCTION AGAIN, PASSING THE CSP PROBLEM INSTANCE AND THE BEST STATE, TO OBTAIN THE COST OF THE BEST STATE.
    # 	4. IT COMPARES THE COSTS OF THE CURRENT STATE AND THE BEST STATE.
    # 	5. IF THE COST OF THE CURRENT STATE IS LESS THAN THE COST OF THE BEST STATE, IT MEANS THE CURRENT STATE IS BETTER.
    # 	6. IN THIS CASE, THE FUNCTION RETURNS TRUE TO INDICATE THAT THE CURRENT STATE IS BETTER THAN THE BEST STATE.
    # 	7. OTHERWISE, IF THE COST OF THE CURRENT STATE IS GREATER THAN OR EQUAL TO THE COST OF THE BEST STATE, THE FUNCTION RETURNS FALSE.
    # THE `__BETTER__()` FUNCTION PLAYS A KEY ROLE IN THE SEARCH PROCESS. BY COMPARING THE COSTS OF DIFFERENT STATES, IT ALLOWS THE ALGORITHM TO MAKE DECISIONS BASED ON THE IMPROVEMENT OF THE CURRENT STATE COMPARED TO THE BEST STATE FOUND SO FAR. THIS HELPS TO DRIVE THE SEARCH TOWARDS BETTER SOLUTIONS BY FAVORING STATES WITH LOWER COSTS.
    def __BETTER__(CURRENT_STATE: dict, BEST_STATE: dict) -> bool:
        """THE `__BETTER__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT IS RESPONSIBLE FOR COMPARING THE QUALITY OF THE CURRENT STATE WITH THE BEST STATE FOUND SO FAR. IT IS USED BY THE `LATE_ACCEPTANCE_HILL_CLIMBING()` FUNCTION TO DETERMINE IF THE CURRENT STATE REPRESENTS AN IMPROVEMENT OVER THE BEST STATE."""
        # CALL THE `__CALCULATE_COST__()` FUNCTION, PASSING THE CSP PROBLEM INSTANCE AND THE CURRENT STATE, TO OBTAIN THE COST OF THE CURRENT STATE
        CURRENT_COST = __CALCULATE_COST__(CURRENT_STATE)
        # CALL THE `__CALCULATE_COST__()` FUNCTION AGAIN, PASSING THE CSP PROBLEM INSTANCE AND THE BEST STATE, TO OBTAIN THE COST OF THE BEST STATE
        BEST_COST = __CALCULATE_COST__(BEST_STATE)
        if CURRENT_COST < BEST_COST:  # IF THE COST OF THE CURRENT STATE IS LESS THAN THE COST OF THE BEST STATE
            return True  # RETURN TRUE TO INDICATE THAT THE CURRENT STATE IS BETTER THAN THE BEST STATE
        return False  # OTHERWISE, IF THE COST OF THE CURRENT STATE IS GREATER THAN OR EQUAL TO THE COST OF THE BEST STATE, RETURN FALSE

    # THE `__CALCULATE_COST__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT CALCULATES THE COST OF A GIVEN STATE IN THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT COUNTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
    # 	1. IT TAKES THE CSP PROBLEM INSTANCE AND THE STATE AS INPUT PARAMETERS.
    # 	2. IT INITIALIZES A VARIABLE CALLED `COST` TO KEEP TRACK OF THE COST OF THE STATE. THE COST IS INITIALLY SET TO 0.
    # 	3. IT LOOPS THROUGH EACH CONSTRAINT IN THE CONSTRAINTS OF THE CSP PROBLEM.
    # 	4. FOR EACH CONSTRAINT, IT CHECKS IF THE CONSTRAINT IS NOT SATISFIED BY THE STATE. IT CALLS THE `__SATISFIED__()` FUNCTION, PASSING THE STATE AND THE CONSTRAINT, TO CHECK IF THE CONSTRAINT IS SATISFIED.
    # 	5. IF THE CONSTRAINT IS NOT SATISFIED, IT INCREMENTS THE `COST` VARIABLE BY 1 TO INDICATE THAT ONE CONSTRAINT IS NOT SATISFIED BY THE STATE.
    # 	6. AFTER LOOPING THROUGH ALL CONSTRAINTS, THE FUNCTION RETURNS THE FINAL VALUE OF THE `COST` VARIABLE, WHICH REPRESENTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE.
    # THE `__CALCULATE_COST__()` FUNCTION IS USED TO QUANTIFY THE QUALITY OF A STATE BY COUNTING THE NUMBER OF CONSTRAINTS THAT ARE VIOLATED. A LOWER COST INDICATES A BETTER STATE, AS IT REPRESENTS FEWER CONSTRAINT VIOLATIONS. THE ALGORITHM USES THIS COST INFORMATION TO GUIDE THE SEARCH TOWARDS FINDING A SOLUTION THAT MINIMIZES CONSTRAINT VIOLATIONS.
    def __CALCULATE_COST__(STATE: dict) -> int:
        """THE `__CALCULATE_COST__()` FUNCTION IS A PRIVATE FUNCTION WITHIN THE CLASS THAT CALCULATES THE COST OF A GIVEN STATE IN THE CONSTRAINT SATISFACTION PROBLEM (CSP). IT COUNTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE."""
        COST = 0  # INITIALIZE A VARIABLE TO KEEP TRACK OF THE COST OF THE STATE
        # LOOP THROUGH EACH CONSTRAINT IN THE CONSTRAINTS OF THE CSP PROBLEM
        for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:
            # IF THE CONSTRAINT IS NOT SATISFIED BY THE STATE
            if not __SATISFIED__(STATE, CONSTRAINT):
                COST += 1  # INCREMENT THE COST BY 1 TO INDICATE THAT ONE CONSTRAINT IS NOT SATISFIED BY THE STATE
        return COST  # RETURN THE FINAL VALUE OF THE COST VARIABLE, WHICH REPRESENTS THE NUMBER OF CONSTRAINTS THAT ARE NOT SATISFIED BY THE STATE

    # INITIALIZE THE CURRENT STATE BY GENERATING A RANDOM STATE
    CURRENT_STATE = __GENERATE_RANDOM_STATE__()
    BEST_STATE = CURRENT_STATE  # INITIALIZE THE BEST STATE AS THE CURRENT STATE
    # INITIALIZE THE LAHC LIST WITH THE BEST STATE AS THE INITIAL ELEMENT
    LAHC_LIST = [BEST_STATE]
    # LOOP FOR THE MAXIMUM NUMBER OF ITERATIONS
    for ITERATION in range(MAX_ITERATIONS):
        # RANDOMLY SELECT A VARIABLE FROM THE CSP PROBLEM
        RANDOM_INDEX = __GET_RANDOM_INDEX__(ITERATION)
        # RANDOMLY SELECT A VALUE FOR THE SELECTED VARIABLE
        RANDOM_VARIABLE = CSP_PROBLEM.VARIABLES[RANDOM_INDEX]
        # ASSIGN THE SELECTED VALUE TO THE SELECTED VARIABLE IN THE CURRENT STATE
        RANDOM_VALUE = __SELECT_VALUE__(CURRENT_STATE, RANDOM_VARIABLE)
        # ASSIGN THE SELECTED VALUE TO THE SELECTED VARIABLE IN THE CURRENT STATE
        CURRENT_STATE[RANDOM_VARIABLE] = RANDOM_VALUE
        # IF THE ASSIGNMENT SATISFIES ALL THE CONSTRAINTS OF THE CSP
        if __COMPLETE__(CURRENT_STATE):
            return CURRENT_STATE  # RETURN THE CURRENT STATE AS THE SOLUTION
        # IF THE CURRENT STATE IS BETTER THAN THE BEST STATE
        if __BETTER__(CURRENT_STATE, BEST_STATE):
            BEST_STATE = CURRENT_STATE  # THE CURRENT STATE BECOMES THE NEW BEST STATE
        # APPEND THE BEST STATE TO THE LAHC LIST
        LAHC_LIST.append(BEST_STATE)
        # IF THE CURRENT ITERATION IS GREATER THAN OR EQUAL TO THE LAHC MEMORY LENGTH
        if ITERATION >= LAHC_MEMORY_LENGTH:
            # UPDATE THE CURRENT STATE BY RETRIEVING A STATE FROM THE LAHC LIST BASED ON THE ITERATION NUMBER
            CURRENT_STATE = LAHC_LIST[ITERATION - LAHC_MEMORY_LENGTH]
    return BEST_STATE  # RETURN THE BEST STATE AS THE SOLUTION
