from .CSP import CSP

# IMPLEMENTS THE BACKTRACKING ALGORITHM FOR SOLVING CONSTRAINT SATISFACTION PROBLEMS (CSPS). BACKTRACKING IS A SYSTEMATIC SEARCH ALGORITHM USED TO FIND SOLUTIONS FOR PROBLEMS THAT INVOLVE MAKING A SERIES OF CHOICES THAT NEED TO SATISFY CERTAIN CONSTRAINTS.
# THE INPUT TO THE `BACKTRACKING` FUNCTION IS A `CSP_PROBLEM`, WHICH IS AN INSTANCE OF THE `CSP` CLASS THAT REPRESENTS THE CONSTRAINT SATISFACTION PROBLEM. THE FUNCTION RETURNS EITHER A DICTIONARY REPRESENTING A VALID ASSIGNMENT OF VALUES TO VARIABLES THAT SATISFIES ALL CONSTRAINTS OR `FALSE` IF NO SOLUTION EXISTS.
#     1. THE `BACKTRACKING` FUNCTION DEFINES SEVERAL HELPER FUNCTIONS WITHIN ITS SCOPE, STARTING WITH `__SELECT_UNASSIGNED_VARIABLE__`, `__COMPLETE__`, `__INFERENCE__`, AND `__CONSISTENT__`. THESE HELPER FUNCTIONS ARE USED TO ASSIST IN THE BACKTRACKING PROCESS.
#         - THE `__SELECT_UNASSIGNED_VARIABLE__` FUNCTION IS USED TO SELECT AN UNASSIGNED VARIABLE FROM THE CSP PROBLEM. IT ITERATES THROUGH ALL VARIABLES IN THE PROBLEM AND RETURNS THE FIRST UNASSIGNED VARIABLE IT FINDS.
#         - THE `__COMPLETE__` FUNCTION CHECKS IF THE VARIABLE ASSIGNMENT IS COMPLETE FOR THE CSP PROBLEM. IT RETURNS `TRUE` IF ALL VARIABLES ARE ASSIGNED AND `FALSE` OTHERWISE.
#         - THE `__INFERENCE__` FUNCTION IS USED TO PERFORM INFERENCE. IT UPDATES THE DOMAINS OF NEIGHBOURING VARIABLES BASED ON THE CURRENT ASSIGNMENT OF A VARIABLE. IT REMOVES THE CURRENT ASSIGNED VALUE FROM THE DOMAINS OF NEIGHBOURING VARIABLES TO ENSURE THEY REMAIN CONSISTENT WITH THE CONSTRAINTS.
#         - THE `__CONSISTENT__` FUNCTION CHECKS THE CONSISTENCY OF VARIABLE ASSIGNMENTS. IT VERIFIES THAT THE CURRENT ASSIGNMENT OF A VARIABLE IS CONSISTENT WITH THE CONSTRAINTS OF THE CSP PROBLEM. IT CHECKS IF THERE ARE ANY CONFLICTS WITH THE NEIGHBOURING VARIABLES.
#     2. THE `BACKTRACKING` ALGORITHM STARTS BY INITIALIZING AN EMPTY `ASSIGNMENT` DICTIONARY TO STORE THE VARIABLE ASSIGNMENTS.
#     3. A STACK, NAMED `STACK`, IS INITIALIZED WITH THE INITIAL ASSIGNMENT (AN EMPTY DICTIONARY) AND SERVES AS THE BACKTRACKING MECHANISM.
#     4. THE MAIN LOOP OF THE ALGORITHM RUNS WHILE THE `STACK` IS NOT EMPTY. THE LOOP PERFORMS THE FOLLOWING STEPS:
#         A. POP THE TOP ASSIGNMENT (DICTIONARY) FROM THE `STACK` AND STORE IT IN `CURRENT_ASSIGNMENT`.
#         B. IF `CURRENT_ASSIGNMENT` IS COMPLETE (ALL VARIABLES ARE ASSIGNED), RETURN IT AS THE SOLUTION.
#         C. SELECT AN UNASSIGNED VARIABLE `VARIABLE` USING THE `__SELECT_UNASSIGNED_VARIABLE__` FUNCTION. IF THERE ARE NO UNASSIGNED VARIABLES LEFT, IT MEANS THAT NO SOLUTION EXISTS, AND WE CONTINUE TO THE NEXT ITERATION OF THE LOOP.  
#         D. FOR EACH VALUE IN THE DOMAIN OF THE SELECTED `VARIABLE`, TRY TO ASSIGN THE VALUE AND CHECK IF IT SATISFIES THE CONSTRAINTS USING THE `__CONSISTENT__` FUNCTION.  
#         E. IF THE ASSIGNMENT IS CONSISTENT, CREATE A NEW ASSIGNMENT `NEW_ASSIGNMENT` BY COPYING THE `CURRENT_ASSIGNMENT`, ASSIGNING THE SELECTED VALUE TO `VARIABLE`, AND PERFORM INFERENCE USING THE `__INFERENCE__` FUNCTION (WHICH UPDATES THE DOMAINS OF NEIGHBOURING VARIABLES).  
#         F. PUSH THE `NEW_ASSIGNMENT` ONTO THE `STACK` TO EXPLORE IT FURTHER.
#     5. IF THE LOOP COMPLETES WITHOUT FINDING A SOLUTION (I.E., THE `STACK` BECOMES EMPTY), THE FUNCTION RETURNS `FALSE` TO INDICATE THAT NO SOLUTION EXISTS FOR THE CSP PROBLEM.
# IN SUMMARY, THE BACKTRACKING ALGORITHM SYSTEMATICALLY EXPLORES DIFFERENT VARIABLE ASSIGNMENTS AND BACKTRACKS WHEN IT ENCOUNTERS CONFLICTS, EVENTUALLY FINDING A VALID ASSIGNMENT OF VALUES TO VARIABLES THAT SATISFIES ALL THE CONSTRAINTS OF THE GIVEN CSP PROBLEM OR DETERMINING THAT NO SUCH ASSIGNMENT EXISTS.
def BACKTRACKING(CSP_PROBLEM: CSP) -> dict | bool:
    """THE `BACKTRACKING` FUNCTION IS AN IMPLEMENTATION OF THE BACKTRACKING ALGORITHM FOR SOLVING CONSTRAINT SATISFACTION PROBLEMS (CSPS). THE FUNCTION TAKES A CSP PROBLEM AS INPUT AND RETURNS EITHER A DICTIONARY REPRESENTING A VALID ASSIGNMENT OF VALUES TO VARIABLES THAT SATISFIES ALL CONSTRAINTS OR `FALSE` IF NO SOLUTION EXISTS.
    THE BACKTRACKING ALGORITHM SYSTEMATICALLY EXPLORES DIFFERENT VARIABLE ASSIGNMENTS, FOLLOWING A DEPTH-FIRST SEARCH APPROACH. IT STARTS WITH AN EMPTY ASSIGNMENT AND RECURSIVELY ASSIGNS VALUES TO VARIABLES, BACKTRACKING WHENEVER A CONFLICT IS ENCOUNTERED.
        1. IT INITIALIZES AN EMPTY ASSIGNMENT AND A STACK TO KEEP TRACK OF ASSIGNMENTS.
        2. WHILE THE STACK IS NOT EMPTY:
            A. POP THE TOP ASSIGNMENT FROM THE STACK.
            B. IF THE ASSIGNMENT IS COMPLETE (ALL VARIABLES ARE ASSIGNED), RETURN IT AS THE SOLUTION.
            C. SELECT AN UNASSIGNED VARIABLE.
            D. FOR EACH VALUE IN THE DOMAIN OF THE SELECTED VARIABLE:
                - ASSIGN THE VALUE TO THE VARIABLE.
                - CHECK IF THE ASSIGNMENT IS CONSISTENT WITH THE CONSTRAINTS.
                - IF IT IS CONSISTENT, CREATE A NEW ASSIGNMENT, UPDATE THE DOMAINS OF NEIGHBORING VARIABLES, AND PUSH THE NEW ASSIGNMENT ONTO THE STACK.
            E. IF NO CONSISTENT ASSIGNMENT IS FOUND, CONTINUE TO THE NEXT ITERATION OF THE LOOP.
        3. IF THE STACK BECOMES EMPTY, IT MEANS NO SOLUTION EXISTS, SO THE FUNCTION RETURNS `FALSE`.
    THE ALGORITHM UTILIZES VARIOUS HELPER FUNCTIONS TO PERFORM TASKS SUCH AS SELECTING UNASSIGNED VARIABLES, CHECKING ASSIGNMENT COMPLETENESS, PERFORMING INFERENCE, AND CHECKING ASSIGNMENT CONSISTENCY.
    OVERALL, THE BACKTRACKING ALGORITHM EXPLORES THE SOLUTION SPACE OF A CSP PROBLEM BY TRYING DIFFERENT ASSIGNMENTS AND BACKTRACKING WHENEVER A CONFLICT ARISES, EVENTUALLY FINDING A VALID ASSIGNMENT THAT SATISFIES ALL CONSTRAINTS OR DETERMINING THAT NO SUCH ASSIGNMENT EXISTS."""

    # THE `__SELECT_UNASSIGNED_VARIABLE__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` FUNCTION TO SELECT AN UNASSIGNED VARIABLE FROM THE CSP PROBLEM.
    #     1. THE `__SELECT_UNASSIGNED_VARIABLE__` FUNCTION TAKES ONE ARGUMENT: `ASSIGNMENT`, WHICH IS A DICTIONARY CONTAINING THE CURRENT VARIABLE ASSIGNMENTS.
    #     2. THE FUNCTION ITERATES OVER THE VARIABLES IN THE CSP PROBLEM.
    #     3. FOR EACH VARIABLE, IT CHECKS IF THE VARIABLE IS NOT PRESENT IN THE `ASSIGNMENT` DICTIONARY. IF THE VARIABLE IS NOT PRESENT, IT MEANS THAT THE VARIABLE HAS NOT BEEN ASSIGNED A VALUE YET.
    #     4. IF AN UNASSIGNED VARIABLE IS FOUND, THE FUNCTION RETURNS THAT VARIABLE.
    #     5. IF NO UNASSIGNED VARIABLE IS FOUND AFTER ITERATING OVER ALL VARIABLES, THE FUNCTION RETURNS `NONE` TO INDICATE THAT ALL VARIABLES HAVE BEEN ASSIGNED.
    # THE `__SELECT_UNASSIGNED_VARIABLE__` FUNCTION SIMPLY FINDS THE FIRST VARIABLE THAT HAS NOT BEEN ASSIGNED A VALUE YET, PROVIDING A WAY TO SELECT AN UNASSIGNED VARIABLE FOR ASSIGNMENT IN THE BACKTRACKING ALGORITHM.
    def __SELECT_UNASSIGNED_VARIABLE__(ASSIGNMENT: dict) -> str | None:
        """THE `__SELECT_UNASSIGNED_VARIABLE__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` ALGORITHM TO CHOOSE AN UNASSIGNED VARIABLE FROM THE CSP PROBLEM. ITS PURPOSE IS TO SELECT THE NEXT VARIABLE THAT NEEDS TO BE ASSIGNED A VALUE.
            1. TAKES AN ASSIGNMENT DICTIONARY AS INPUT, WHICH CONTAINS THE VARIABLES ALREADY ASSIGNED WITH THEIR CORRESPONDING VALUES.
            2. ITERATES THROUGH EACH VARIABLE IN THE CSP PROBLEM.
            3. CHECKS IF THE VARIABLE IS NOT ALREADY ASSIGNED BY VERIFYING IF IT EXISTS IN THE ASSIGNMENT DICTIONARY.
            4. IF AN UNASSIGNED VARIABLE IS FOUND, IT IS IMMEDIATELY RETURNED.
            5. IF NO UNASSIGNED VARIABLE IS FOUND AFTER ITERATING THROUGH ALL VARIABLES, IT RETURNS `NONE` TO INDICATE THAT THERE ARE NO UNASSIGNED VARIABLES LEFT.
        THE FUNCTION PLAYS A CRUCIAL ROLE IN DETERMINING THE ORDER IN WHICH VARIABLES ARE SELECTED FOR ASSIGNMENT, AFFECTING THE EFFICIENCY AND SEARCH SPACE OF THE BACKTRACKING ALGORITHM. BY SELECTING UNASSIGNED VARIABLES, THE ALGORITHM EXPLORES DIFFERENT VARIABLE ASSIGNMENTS SYSTEMATICALLY UNTIL A SOLUTION IS FOUND OR DETERMINES THAT NO SOLUTION EXISTS."""
        for VARIABLE in CSP_PROBLEM.VARIABLES:  # ITERATE OVER VARIABLES
            if VARIABLE not in ASSIGNMENT:  # IF VARIABLE IS NOT IN ASSIGNMENT
                return VARIABLE  # RETURN VARIABLE
        return None  # IF NO UNASSIGNED VARIABLE IS FOUND, RETURN NONE

    # THE `__COMPLETE__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` FUNCTION TO CHECK IF THE VARIABLE ASSIGNMENT IS COMPLETE FOR THE CSP PROBLEM.
    #     1. THE `__COMPLETE__` FUNCTION TAKES ONE ARGUMENT: `ASSIGNMENT`, WHICH IS A DICTIONARY CONTAINING THE CURRENT VARIABLE ASSIGNMENTS.
    #     2. THE FUNCTION ITERATES OVER THE VARIABLES IN THE CSP PROBLEM.
    #     3. FOR EACH VARIABLE, IT CHECKS IF THE VARIABLE IS NOT PRESENT IN THE `ASSIGNMENT` DICTIONARY. IF THE VARIABLE IS NOT PRESENT, IT MEANS THAT THE VARIABLE HAS NOT BEEN ASSIGNED A VALUE YET.
    #     4. IF ANY VARIABLE IS FOUND THAT HAS NOT BEEN ASSIGNED A VALUE, THE FUNCTION RETURNS `FALSE` TO INDICATE THAT THE ASSIGNMENT IS NOT COMPLETE.
    #     5. IF ALL VARIABLES HAVE BEEN ASSIGNED A VALUE (I.E., NONE OF THEM ARE MISSING IN THE `ASSIGNMENT` DICTIONARY), THE FUNCTION RETURNS `TRUE` TO INDICATE THAT THE ASSIGNMENT IS COMPLETE.
    # THE `__COMPLETE__` FUNCTION SIMPLY CHECKS IF ALL VARIABLES IN THE CSP PROBLEM HAVE BEEN ASSIGNED VALUES, PROVIDING A WAY TO DETERMINE IF THE ASSIGNMENT IS COMPLETE IN THE BACKTRACKING ALGORITHM.
    def __COMPLETE__(ASSIGNMENT: dict) -> bool:
        """THE `__COMPLETE__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` ALGORITHM TO CHECK IF THE VARIABLE ASSIGNMENT IS COMPLETE FOR THE CONSTRAINT SATISFACTION PROBLEM (CSP).
            1. IT TAKES AN ASSIGNMENT DICTIONARY AS INPUT.
            2. IT ITERATES THROUGH EACH VARIABLE IN THE CSP PROBLEM.
            3. FOR EACH VARIABLE, IT CHECKS IF THE VARIABLE IS NOT ASSIGNED IN THE INPUT ASSIGNMENT DICTIONARY.
            4. IF IT FINDS ANY UNASSIGNED VARIABLE DURING THE ITERATION, IT IMMEDIATELY RETURNS `FALSE` TO INDICATE THAT THE ASSIGNMENT IS NOT COMPLETE.
            5. IF IT COMPLETES THE ITERATION WITHOUT FINDING ANY UNASSIGNED VARIABLES, IT MEANS THAT ALL VARIABLES HAVE BEEN ASSIGNED VALUES, AND IT RETURNS `TRUE` TO INDICATE THAT THE ASSIGNMENT IS COMPLETE.
        IN SUMMARY, THE `__COMPLETE__` FUNCTION IS RESPONSIBLE FOR DETERMINING WHETHER THE VARIABLE ASSIGNMENT IS COMPLETE OR NOT. IT HELPS IN IDENTIFYING WHEN ALL VARIABLES HAVE BEEN ASSIGNED VALUES, WHICH IS A TERMINATION CONDITION FOR THE BACKTRACKING ALGORITHM."""
        for VARIABLE in CSP_PROBLEM.VARIABLES:  # ITERATE OVER VARIABLES
            if VARIABLE not in ASSIGNMENT:  # IF VARIABLE IS NOT IN ASSIGNMENT
                return False  # RETURN FALSE
        return True  # IF ALL VARIABLES ARE IN ASSIGNMENT, RETURN TRUE

    # THE `__INFERENCE__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` FUNCTION TO PERFORM INFERENCE. IT UPDATES THE DOMAINS OF NEIGHBORING VARIABLES BASED ON THE CURRENT ASSIGNMENT OF A VARIABLE.
    #     1. THE `__INFERENCE__` FUNCTION TAKES TWO ARGUMENTS: `VARIABLE`, WHICH IS THE SELECTED VARIABLE THAT WAS ASSIGNED A VALUE, AND `VALUE`, WHICH IS THE ASSIGNED VALUE TO THE VARIABLE.
    #     2. THE FUNCTION ITERATES OVER THE NEIGHBORS OF THE `VARIABLE`. NEIGHBORS ARE THE VARIABLES THAT SHARE A CONSTRAINT WITH THE SELECTED VARIABLE.
    #     3. FOR EACH NEIGHBOR VARIABLE, IT CHECKS IF THE `VALUE` IS IN THE DOMAIN OF THE NEIGHBOR VARIABLE.
    #     4. IF THE `VALUE` IS IN THE DOMAIN OF THE NEIGHBOR VARIABLE, IT MEANS THAT THE DOMAIN OF THE NEIGHBOR NEEDS TO BE UPDATED.
    #     5. IN SUCH A CASE, THE FUNCTION REMOVES THE `VALUE` FROM THE DOMAIN OF THE NEIGHBOR VARIABLE, REDUCING THE SEARCH SPACE FOR THAT VARIABLE. THIS IS BASED ON THE CONSTRAINT THAT THE NEIGHBOR VARIABLE CANNOT HAVE THE SAME VALUE AS THE SELECTED VARIABLE.
    #     6. THE FUNCTION CONTINUES THIS PROCESS FOR ALL NEIGHBOR VARIABLES.
    # THE `__INFERENCE__` FUNCTION PERFORMS INFERENCE BY UPDATING THE DOMAINS OF NEIGHBORING VARIABLES BASED ON THE CURRENT ASSIGNMENT. THIS REDUCES THE SEARCH SPACE AND HELPS TO PRUNE UNNECESSARY ASSIGNMENTS, IMPROVING THE EFFICIENCY OF THE BACKTRACKING ALGORITHM.
    def __INFERENCE__(VARIABLE: str, VALUE: str) -> None:
        """THE `__INFERENCE__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` ALGORITHM TO PERFORM INFERENCE OR DOMAIN REDUCTION DURING THE ASSIGNMENT OF A VARIABLE IN THE CONSTRAINT SATISFACTION PROBLEM (CSP).
            1. TAKES A VARIABLE (`VARIABLE`) AND ITS ASSIGNED VALUE (`VALUE`) AS INPUT.
            2. ITERATES THROUGH EACH NEIGHBORING VARIABLE (`NEIGHBOR`) OF THE GIVEN VARIABLE IN THE CSP PROBLEM.
            3. CHECKS IF THE ASSIGNED VALUE (`VALUE`) IS PRESENT IN THE DOMAIN OF THE NEIGHBORING VARIABLE.
            4. IF THE ASSIGNED VALUE IS FOUND IN THE DOMAIN OF THE NEIGHBORING VARIABLE, IT REMOVES THAT VALUE FROM THE DOMAIN TO ENFORCE CONSISTENCY.
        BY REMOVING VALUES FROM THE DOMAINS OF NEIGHBORING VARIABLES THAT ARE INCONSISTENT WITH THE ASSIGNED VALUE, THE `__INFERENCE__` FUNCTION NARROWS DOWN THE POTENTIAL VALUES FOR THE NEIGHBORING VARIABLES. THIS PROCESS, KNOWN AS INFERENCE, HELPS IN REDUCING THE SEARCH SPACE OF THE PROBLEM AND CAN POTENTIALLY LEAD TO FASTER IDENTIFICATION OF A VALID SOLUTION OR THE DETECTION OF INFEASIBILITY.
        OVERALL, THE `__INFERENCE__` FUNCTION CONTRIBUTES TO THE EFFICIENCY OF THE BACKTRACKING ALGORITHM BY REDUCING THE NUMBER OF POTENTIAL ASSIGNMENTS AND INCREASING THE CHANCES OF FINDING A VALID SOLUTION FOR THE CSP PROBLEM."""
        for NEIGHBOR in CSP_PROBLEM.NEIGHBORS[VARIABLE]:  # ITERATE OVER NEIGHBORS
            # IF VALUE IS IN DOMAIN OF NEIGHBOR
            if VALUE in CSP_PROBLEM.DOMAINS[NEIGHBOR]:
                # REMOVE VALUE FROM DOMAIN OF NEIGHBOR
                CSP_PROBLEM.DOMAINS[NEIGHBOR].remove(VALUE)

    # THE `__CONSISTENT__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` FUNCTION TO CHECK THE CONSISTENCY OF VARIABLE ASSIGNMENTS. IT ENSURES THAT THE CURRENT ASSIGNMENT OF A VARIABLE IS CONSISTENT WITH THE CONSTRAINTS OF THE CSP PROBLEM.
    #     1. THE `__CONSISTENT__` FUNCTION TAKES THREE ARGUMENTS: `ASSIGNMENT`, WHICH IS A DICTIONARY CONTAINING THE CURRENT VARIABLE ASSIGNMENTS, `VARIABLE`, WHICH IS THE SELECTED VARIABLE, AND `VALUE`, WHICH IS THE ASSIGNED VALUE TO THE VARIABLE.
    #     2. THE FUNCTION ITERATES OVER THE CONSTRAINTS OF THE CSP PROBLEM. CONSTRAINTS DEFINE RELATIONSHIPS BETWEEN VARIABLES.
    #     3. FOR EACH CONSTRAINT, IT CHECKS IF THE SELECTED VARIABLE `VARIABLE` IS INVOLVED IN THE CONSTRAINT.
    #     4. IF THE SELECTED VARIABLE IS INVOLVED, IT ITERATES OVER THE VARIABLES IN THE CONSTRAINT.
    #     5. FOR EACH VARIABLE `VARIABLE_2` IN THE CONSTRAINT, IT CHECKS IF `VARIABLE_2` IS NOT EQUAL TO `VARIABLE`.
    #     6. IF `VARIABLE_2` IS NOT EQUAL TO `VARIABLE`, IT CHECKS IF `VARIABLE_2` IS PRESENT IN THE `ASSIGNMENT` DICTIONARY, INDICATING THAT `VARIABLE_2` HAS BEEN ASSIGNED A VALUE.
    #     7. IF `VARIABLE_2` IS ASSIGNED A VALUE, IT COMPARES THE VALUE OF `VARIABLE_2` WITH THE ASSIGNED VALUE `VALUE`.
    #     8. IF THE VALUES ARE EQUAL, IT MEANS THAT THE ASSIGNMENT VIOLATES THE CONSTRAINT, AND THE FUNCTION RETURNS `FALSE` TO INDICATE INCONSISTENCY.
    #     9. IF NO INCONSISTENCIES ARE FOUND AMONG THE CONSTRAINTS, THE FUNCTION RETURNS `TRUE` TO INDICATE THAT THE ASSIGNMENT IS CONSISTENT.
    # THE `__CONSISTENT__` FUNCTION ENSURES THAT THE CURRENT ASSIGNMENT OF A VARIABLE DOES NOT VIOLATE ANY CONSTRAINTS IN THE CSP PROBLEM. IT CHECKS FOR CONSISTENCY BETWEEN THE SELECTED VARIABLE AND OTHER ASSIGNED VARIABLES, PROVIDING A MECHANISM TO ENSURE THAT ASSIGNMENTS FOLLOW THE CONSTRAINTS OF THE PROBLEM DURING THE BACKTRACKING SEARCH.
    def __CONSISTENT__(ASSIGNMENT: dict, VARIABLE: str, VALUE: str) -> bool:
        """THE `__CONSISTENT__` FUNCTION IS A PRIVATE HELPER FUNCTION USED WITHIN THE `BACKTRACKING` ALGORITHM TO CHECK THE CONSISTENCY OF VARIABLE ASSIGNMENTS IN THE CONSTRAINT SATISFACTION PROBLEM (CSP).
            1. TAKES AN ASSIGNMENT DICTIONARY (`ASSIGNMENT`), A VARIABLE (`VARIABLE`), AND A VALUE (`VALUE`) AS INPUT.
            2. ITERATES THROUGH EACH CONSTRAINT IN THE CSP PROBLEM.
            3. CHECKS IF THE CURRENT VARIABLE (`VARIABLE`) IS INVOLVED IN THE CONSTRAINT.
            4. FOR EACH CONSTRAINT, IT EXAMINES EACH OTHER VARIABLE (`VARIABLE_2`) IN THE CONSTRAINT.
            5. IF THE OTHER VARIABLE (`VARIABLE_2`) IS ALREADY ASSIGNED (PRESENT IN THE ASSIGNMENT DICTIONARY), IT COMPARES ITS ASSIGNED VALUE (`ASSIGNMENT[VARIABLE_2]`) WITH THE CURRENT VALUE (`VALUE`).
            6. IF THE ASSIGNED VALUE (`ASSIGNMENT[VARIABLE_2]`) IS THE SAME AS THE CURRENT VALUE (`VALUE`), IT INDICATES A CONSTRAINT VIOLATION, AND THE FUNCTION RETURNS `FALSE` TO INDICATE INCONSISTENCY.
            7. IF NO CONSTRAINT VIOLATIONS ARE FOUND IN THE LOOP, IT MEANS THE CURRENT ASSIGNMENT IS CONSISTENT WITH ALL CONSTRAINTS, AND THE FUNCTION RETURNS `TRUE` TO INDICATE CONSISTENCY.
        THE `__CONSISTENT__` FUNCTION IS CRUCIAL IN ENSURING THAT THE CURRENT ASSIGNMENT OF A VARIABLE ADHERES TO THE CONSTRAINTS OF THE CSP PROBLEM. IT HELPS IN PRUNING INCONSISTENT ASSIGNMENTS, LEADING TO A MORE EFFICIENT SEARCH FOR VALID SOLUTIONS DURING THE BACKTRACKING ALGORITHM."""
        for CONSTRAINT in CSP_PROBLEM.CONSTRAINTS:  # ITERATE OVER CONSTRAINTS
            if VARIABLE in CONSTRAINT:  # IF VARIABLE IS IN CONSTRAINT
                for VARIABLE_2 in CONSTRAINT:  # ITERATE OVER VARIABLES IN CONSTRAINT
                    if VARIABLE_2 != VARIABLE:  # IF VARIABLE_2 IS NOT EQUAL TO VARIABLE
                        if VARIABLE_2 in ASSIGNMENT:  # IF VARIABLE_2 IS IN ASSIGNMENT
                            # IF VALUE IS EQUAL TO ASSIGNMENT[VARIABLE_2]
                            if VALUE == ASSIGNMENT[VARIABLE_2]:
                                return False  # RETURN FALSE
        return True  # RETURN TRUE
    
    ASSIGNMENT = {}  # INITIALIZE ASSIGNMENT
    STACK = [ASSIGNMENT]  # INITIALIZE STACK
    while STACK:  # WHILE STACK IS NOT EMPTY
        CURRENT_ASSIGNMENT = STACK.pop()  # POP ASSIGNMENT FROM STACK
        if __COMPLETE__(CURRENT_ASSIGNMENT):  # IF ASSIGNMENT IS COMPLETE
            return CURRENT_ASSIGNMENT  # RETURN ASSIGNMENT
        VARIABLE = __SELECT_UNASSIGNED_VARIABLE__(
            CURRENT_ASSIGNMENT)  # SELECT UNASSIGNED VARIABLE
        if VARIABLE is None:  # IF NO UNASSIGNED VARIABLE
            continue  # CONTINUE
        # ITERATE OVER DOMAIN OF VARIABLE
        for VALUE in CSP_PROBLEM.DOMAINS[VARIABLE]:
            # IF ASSIGNMENT IS CONSISTENT
            if __CONSISTENT__(CURRENT_ASSIGNMENT, VARIABLE, VALUE):
                NEW_ASSIGNMENT = dict(CURRENT_ASSIGNMENT)  # COPY ASSIGNMENT
                NEW_ASSIGNMENT[VARIABLE] = VALUE  # ASSIGN VALUE TO VARIABLE
                __INFERENCE__(VARIABLE, VALUE)  # PERFORM INFERENCE
                STACK.append(NEW_ASSIGNMENT)  # PUSH ASSIGNMENT TO STACK
    return False  # RETURN FALSE
