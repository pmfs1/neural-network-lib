import numpy as np
from DECISION_TREE import DECISION_TREE

# RANDOM_FOREST: CLASS THAT IMPLEMENTS RANDOM FOREST MODEL
class RANDOM_FOREST:
    # INITIALIZES THE RANDOM FOREST MODEL
    def __init__(self, N_TREES=10, MIN_SAMPLES_SPLIT=2, MAX_DEPTH=100, N_FEATURES=None):
        # N_TREES: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF TREES.
        self.N_TREES = N_TREES
        # MIN_SAMPLES_SPLIT: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE MINIMUM NUMBER OF SAMPLES REQUIRED TO SPLIT AN INTERNAL NODE.
        self.MIN_SAMPLES_SPLIT = MIN_SAMPLES_SPLIT
        # MAX_DEPTH: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE MAXIMUM DEPTH OF THE TREE.
        self.MAX_DEPTH = MAX_DEPTH
        # N_FEATURES: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF FEATURES.
        self.N_FEATURES = N_FEATURES
        # TREES: IT'S THE LIST THAT CONTAINS THE TREES OF THE MODEL.
        self.TREES = []

    # FIT(): METHOD THAT TRAINS THE RANDOM FOREST MODEL
    def FIT(self, X, Y):
        self.TREES = []  # INITIALIZES THE LIST OF TREES
        for _ in range(self.N_TREES):  # FOR EACH TREE
            TREE = DECISION_TREE(MIN_SAMPLES_SPLIT=self.MIN_SAMPLES_SPLIT,
                                 MAX_DEPTH=self.MAX_DEPTH, N_FEATURES=self.N_FEATURES)  # CREATES A DECISION TREE
            X_SAMP, Y_SAMP = self.__BOOTSTRAP_SAMPLE__(
                X, Y)  # CREATES A BOOTSTRAP SAMPLE
            TREE.FIT(X_SAMP, Y_SAMP)  # TRAINS THE DECISION TREE
            # APPENDS THE DECISION TREE TO THE LIST OF TREES
            self.TREES.append(TREE)

    # TRANSFORM(): METHOD THAT TRANSFORMS THE DATASET INTO A MATRIX OF PREDICTIONS
    def TRANSFORM(self, X):
        # CREATES A MATRIX OF PREDICTIONS
        TREE_HYPOTHESES = np.array([TREE.PREDICT(X) for TREE in self.TREES])
        # TRANSPOSES THE MATRIX OF PREDICTIONS
        TREE_HYPOTHESES = np.swapaxes(TREE_HYPOTHESES, 0, 1)
        Y_HYPOTHESES = [DECISION_TREE.__MOST_COMMON_LABEL__(
            TREE_HYPOTHESIS) for TREE_HYPOTHESIS in TREE_HYPOTHESES]  # CREATES A LIST OF PREDICTIONS
        return np.array(Y_HYPOTHESES)  # RETURNS THE LIST OF PREDICTIONS

    # __BOOTSTRAP_SAMPLE__() [STATIC & PRIVATE]: METHOD THAT CREATES A BOOTSTRAP SAMPLE
    @staticmethod
    def __BOOTSTRAP_SAMPLE__(X, Y):
        # NUMBER OF SAMPLES: IT'S THE NUMBER OF SAMPLES OF THE DATASET.
        N_SAMPLES = X.shape[0]
        # INDEX LENGTHS: IT'S THE LIST OF INDEX LENGTHS.
        INDEX_LENGTHS = np.random.choice(N_SAMPLES, N_SAMPLES, replace=True)
        # RETURNS THE BOOTSTRAP SAMPLE
        return X[INDEX_LENGTHS], Y[INDEX_LENGTHS]