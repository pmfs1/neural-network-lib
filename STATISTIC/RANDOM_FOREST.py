import numpy as np
from DECISION_TREE import DECISION_TREE

# RANDOM_FOREST: CLASS THAT IMPLEMENTS RANDOM FOREST MODEL
class RANDOM_FOREST:
    # INITIALIZES THE RANDOM FOREST MODEL
    def __init__(self, N_TREES=10, MIN_SAMPLES_SPLIT=2, MAX_DEPTH=100, N_FEATURES=None):
        self.N_TREES = N_TREES # N_TREES: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF TREES.
        self.MIN_SAMPLES_SPLIT = MIN_SAMPLES_SPLIT # MIN_SAMPLES_SPLIT: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE MINIMUM NUMBER OF SAMPLES REQUIRED TO SPLIT AN INTERNAL NODE.
        self.MAX_DEPTH = MAX_DEPTH # MAX_DEPTH: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE MAXIMUM DEPTH OF THE TREE.
        self.N_FEATURES = N_FEATURES # N_FEATURES: IT'S THE HYPERPARAMETER THAT CORRESPONDS TO THE NUMBER OF FEATURES.
        self.TREES = [] # TREES: IT'S THE LIST THAT CONTAINS THE TREES OF THE MODEL.

    # FIT(): METHOD THAT TRAINS THE RANDOM FOREST MODEL
    def FIT(self, X, Y):
        self.TREES = [] # INITIALIZES THE LIST OF TREES
        for _ in range(self.N_TREES): # FOR EACH TREE
            TREE = DECISION_TREE(MIN_SAMPLES_SPLIT=self.MIN_SAMPLES_SPLIT, MAX_DEPTH=self.MAX_DEPTH, N_FEATURES=self.N_FEATURES) # CREATES A DECISION TREE
            X_SAMP, Y_SAMP = self.__BOOTSTRAP_SAMPLE__(X, Y) # CREATES A BOOTSTRAP SAMPLE
            TREE.FIT(X_SAMP, Y_SAMP) # TRAINS THE DECISION TREE
            self.TREES.append(TREE) # APPENDS THE DECISION TREE TO THE LIST OF TREES

    # TRANSFORM(): METHOD THAT TRANSFORMS THE DATASET INTO A MATRIX OF PREDICTIONS
    def TRANSFORM(self, X):
        TREE_HYPOTHESES = np.array([TREE.PREDICT(X) for TREE in self.TREES]) # CREATES A MATRIX OF PREDICTIONS
        TREE_HYPOTHESES = np.swapaxes(TREE_HYPOTHESES, 0, 1) # TRANSPOSES THE MATRIX OF PREDICTIONS
        Y_HYPOTHESES = [DECISION_TREE.__MOST_COMMON_LABEL__(TREE_HYPOTHESIS) for TREE_HYPOTHESIS in TREE_HYPOTHESES] # CREATES A LIST OF PREDICTIONS
        return np.array(Y_HYPOTHESES) # RETURNS THE LIST OF PREDICTIONS
    
    # __BOOTSTRAP_SAMPLE__() [STATIC & PRIVATE]: METHOD THAT CREATES A BOOTSTRAP SAMPLE
    @staticmethod
    def __BOOTSTRAP_SAMPLE__(X, Y):
        N_SAMPLES = X.shape[0] # NUMBER OF SAMPLES: IT'S THE NUMBER OF SAMPLES OF THE DATASET.
        INDEX_LENGTHS = np.random.choice(N_SAMPLES, N_SAMPLES, replace=True) # INDEX LENGTHS: IT'S THE LIST OF INDEX LENGTHS.
        return X[INDEX_LENGTHS], Y[INDEX_LENGTHS] # RETURNS THE BOOTSTRAP SAMPLE